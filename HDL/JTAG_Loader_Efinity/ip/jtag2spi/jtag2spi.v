// =============================================================================
// Generated by efx_ipmgr
// Version: 2023.2.307
// IP Version: 5.1
// =============================================================================

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2023 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//                                                                       
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//                                                                       
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.                                                
//
////////////////////////////////////////////////////////////////////////////////

`define IP_UUID _9a8539ca3cf541d89d2d71213874ec84
`define IP_NAME_CONCAT(a,b) a``b
`define IP_MODULE_NAME(name) `IP_NAME_CONCAT(name,`IP_UUID)
module jtag2spi (
input rstn,
input clkin,
input miso,
output sclk,
output nss,
output mosi,
input jtag_inst1_CAPTURE,
input jtag_inst1_DRCK,
input jtag_inst1_RESET,
input jtag_inst1_RUNTEST,
input jtag_inst1_SEL,
input jtag_inst1_SHIFT,
input jtag_inst1_TCK,
input jtag_inst1_TDI,
input jtag_inst1_TMS,
input jtag_inst1_UPDATE,
output jtag_inst1_TDO,
output wp_n,
output hold_n,
output osc_inst1_ENA
);


`IP_MODULE_NAME(efx_spi_loader_top) #(
.FPGA_ID (1),
.WFIFO_DEPTH_256 (60),
.RFIFO_DEPTH_256 (60),
.ENABLE_DUAL_FLASH (1'b0)
) u_efx_spi_loader_top(
.rstn ( 1 ),
.clkin ( clkin ),
.miso ( miso ),
.sclk ( sclk ),
.nss ( nss ),
.mosi ( mosi ),
.jtag_inst1_CAPTURE ( jtag_inst1_CAPTURE ),
.jtag_inst1_DRCK ( jtag_inst1_DRCK ),
.jtag_inst1_RESET ( jtag_inst1_RESET ),
.jtag_inst1_RUNTEST ( jtag_inst1_RUNTEST ),
.jtag_inst1_SEL ( jtag_inst1_SEL ),
.jtag_inst1_SHIFT ( jtag_inst1_SHIFT ),
.jtag_inst1_TCK ( jtag_inst1_TCK ),
.jtag_inst1_TDI ( jtag_inst1_TDI ),
.jtag_inst1_TMS ( jtag_inst1_TMS ),
.jtag_inst1_UPDATE ( jtag_inst1_UPDATE ),
.jtag_inst1_TDO ( jtag_inst1_TDO ),
.wp_n ( wp_n ),
.hold_n ( hold_n ),
.osc_inst1_ENA ( osc_inst1_ENA )
);

endmodule

//////////////////////////////////////////////////////////////////////
// File:  CRC32.v                             
// Date:  Thu Nov 27 13:56:49 2003                                                      
//                                                                     
// Copyright (C) 1999-2003 Easics NV.                 
// This source file may be used and distributed without restriction    
// provided that this copyright statement is not removed from the file 
// and that any derivative work contains the original copyright notice
// and the associated disclaimer.
//
// THIS SOURCE FILE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS
// OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
// WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Purpose: Verilog module containing a synthesizable CRC function
//   * polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)
//   * data width: 1
//                                                                     
// Info: janz@easics.be (Jan Zegers)                           
//       http://www.easics.com
//
// Modified by Nathan Yawn for the Advanced Debug Module
// Changes (C) 2008 - 2010 Nathan Yawn                                 
///////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: Revision 1 2019/07/23 05:33:11 GMT cllee $
//   First release from Windows
// Revision 1.3  2011-10-24 02:25:11  natey
// Removed extraneous '#1' delays, which were a holdover from the original
// versions in the previous dbg_if core.
//
// Revision 1.2  2010-01-10 22:54:10  Nathan
// Update copyright dates
//
// Revision 1.1  2008/07/22 20:28:29  Nathan
// Changed names of all files and modules (prefixed an a, for advanced).  Cleanup, indenting.  No functional changes.
//
// Revision 1.3  2008/07/06 20:02:53  Nathan
// Fixes for synthesis with Xilinx ISE (also synthesizable with 
// Quartus II 7.0).  Ran through dos2unix.
//
// Revision 1.2  2008/06/20 19:22:10  Nathan
// Reversed the direction of the CRC computation shift, for a more 
// hardware-efficient implementation.
//
//
//
//

`timescale 1 ps/1 ps
module `IP_MODULE_NAME(adbg_crc32) (clk, data, enable, shift, clr, rstn, crc_out, serial_out);
    input         clk;
    input         data;
    input         enable;
    input         shift;
    input         clr;
    input         rstn;
    output [31:0] crc_out;
    output        serial_out;

    reg    [31:0] crc;
    wire   [31:0] new_crc;

    // You may notice that the 'poly' in this implementation is backwards.
    // This is because the shift is also 'backwards', so that the data can
    // be shifted out in the same direction, which saves on logic + routing.
    assign new_crc[0] = crc[1];
    assign new_crc[1] = crc[2];
    assign new_crc[2] = crc[3];
    assign new_crc[3] = crc[4];
    assign new_crc[4] = crc[5];
    assign new_crc[5] = crc[6] ^ data ^ crc[0];
    assign new_crc[6] = crc[7];
    assign new_crc[7] = crc[8];
    assign new_crc[8] = crc[9] ^ data ^ crc[0];
    assign new_crc[9] = crc[10] ^ data ^ crc[0];
    assign new_crc[10] = crc[11];
    assign new_crc[11] = crc[12];
    assign new_crc[12] = crc[13];
    assign new_crc[13] = crc[14];
    assign new_crc[14] = crc[15];
    assign new_crc[15] = crc[16] ^ data ^ crc[0];
    assign new_crc[16] = crc[17];
    assign new_crc[17] = crc[18];
    assign new_crc[18] = crc[19];
    assign new_crc[19] = crc[20] ^ data ^ crc[0];
    assign new_crc[20] = crc[21] ^ data ^ crc[0];
    assign new_crc[21] = crc[22] ^ data ^ crc[0];
    assign new_crc[22] = crc[23];
    assign new_crc[23] = crc[24] ^ data ^ crc[0];
    assign new_crc[24] = crc[25] ^ data ^ crc[0];
    assign new_crc[25] = crc[26];
    assign new_crc[26] = crc[27] ^ data ^ crc[0];
    assign new_crc[27] = crc[28] ^ data ^ crc[0];
    assign new_crc[28] = crc[29];
    assign new_crc[29] = crc[30] ^ data ^ crc[0];
    assign new_crc[30] = crc[31] ^ data ^ crc[0];
    assign new_crc[31] =           data ^ crc[0];

    always @ (posedge clk or negedge rstn)
    begin
        if(~rstn)
            crc[31:0] <= 32'hffffffff;
        else if(clr)
            crc[31:0] <= 32'hffffffff;
        else if(enable)
            crc[31:0] <= new_crc;
        else if (shift)
            crc[31:0] <= {1'b0, crc[31:1]};
    end

    //assign crc_match = (crc == 32'h0);
    assign crc_out = crc; //[31];
    assign serial_out = crc[0];
endmodule
// adbg_crc32




/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// Dual Clock FIFO
//
//********************************
// Revisions:
// 0.0 Initial rev
// 0.1 Added read/write count, almost full, almost empty signal
//********************************

module `IP_MODULE_NAME(dual_clock_fifo_wrapper)
#(
	parameter	DATA_WIDTH		= 8,
	parameter	ADDR_WIDTH		= 8,
	parameter	LATENCY			= 1,
	parameter	FIFO_MODE		= "STD_FIFO",
	parameter	RAM_INIT_FILE	= "",
	/////////////////////////////////////////////////////////////////////////////////////
	// compatibility	output_reg			check_full_overflow		check_empty_underflow
	/////////////////////////////////////////////////////////////////////////////////////
	// E				user configurable	user configurable		user configurable
	// X				user configurable	always on				always on
	// A				always off			user configurable		user configurable
	parameter	COMPATIBILITY	= "E",
	parameter	OUTPUT_REG		= "TRUE",
	parameter	CHECK_FULL		= "TRUE",
	parameter	CHECK_EMPTY		= "TRUE",
	parameter	AFULL_THRESHOLD	= 512,	
	parameter	AEMPTY_THRESHOLD= 1					
)
(
	input						i_arst,
	
	input						i_wclk,
	input						i_we,
	input	[DATA_WIDTH-1:0]	i_wdata,
	
	input						i_rclk,
	input						i_re,
	
	output						o_full,
	output						o_empty,
	output	[DATA_WIDTH-1:0]	o_rdata,
	
	output						o_afull,	
	output	[ADDR_WIDTH-1:0]	o_wcnt,		
	output						o_aempty,	
	output	[ADDR_WIDTH-1:0]	o_rcnt		
);

generate
	if (COMPATIBILITY == "X")
	begin
		if (FIFO_MODE == "BYPASS")
		begin
			`IP_MODULE_NAME(dual_clock_fifo)
			#(
				.DATA_WIDTH			(DATA_WIDTH),
				.ADDR_WIDTH			(ADDR_WIDTH),
				.LATENCY			(LATENCY+4),
				.FIFO_MODE			(FIFO_MODE),
				.RAM_INIT_FILE		(RAM_INIT_FILE),
				.COMPATIBILITY		(COMPATIBILITY),
				.OUTPUT_REG			("FALSE"),
				.CHECK_FULL			("TRUE"),
				.CHECK_EMPTY		("TRUE"),
				.AFULL_THRESHOLD	(AFULL_THRESHOLD),
				.AEMPTY_THRESHOLD	(AEMPTY_THRESHOLD)
			)
			inst_dual_clock_fifo
			(
				.i_arst		(i_arst),
				.i_wclk		(i_wclk),
				.i_we		(i_we),
				.i_wdata	(i_wdata),
				.i_rclk		(i_rclk),
				.i_re		(i_re),
				.o_full		(o_full),
				.o_empty	(o_empty),
				.o_rdata	(o_rdata),
				
				.o_afull	(o_afull),
				.o_wcnt		(o_wcnt),
				.o_aempty	(o_aempty),
				.o_rcnt		(o_rcnt)
			);
		end
		else
		begin
			`IP_MODULE_NAME(dual_clock_fifo)
			#(
				.DATA_WIDTH			(DATA_WIDTH),
				.ADDR_WIDTH			(ADDR_WIDTH),
				.LATENCY			(LATENCY+2),
				.FIFO_MODE			(FIFO_MODE),
				.RAM_INIT_FILE		(RAM_INIT_FILE),
				.COMPATIBILITY		(COMPATIBILITY),
				.OUTPUT_REG			(OUTPUT_REG),
				.CHECK_FULL			("TRUE"),
				.CHECK_EMPTY		("TRUE"),
				.AFULL_THRESHOLD	(AFULL_THRESHOLD),
				.AEMPTY_THRESHOLD	(AEMPTY_THRESHOLD)
			)
			inst_dual_clock_fifo
			(
				.i_arst		(i_arst),
				.i_wclk		(i_wclk),
				.i_we		(i_we),
				.i_wdata	(i_wdata),
				.i_rclk		(i_rclk),
				.i_re		(i_re),
				.o_full		(o_full),
				.o_empty	(o_empty),
				.o_rdata	(o_rdata),
				
				.o_afull	(o_afull),
				.o_wcnt		(o_wcnt),
				.o_aempty	(o_aempty),
				.o_rcnt		(o_rcnt)
			);
		end
	end
	else if (COMPATIBILITY == "A")
	begin
		`IP_MODULE_NAME(dual_clock_fifo)
		#(
			.DATA_WIDTH			(DATA_WIDTH),
			.ADDR_WIDTH			(ADDR_WIDTH),
			.LATENCY			(LATENCY),
			.FIFO_MODE			(FIFO_MODE),
			.RAM_INIT_FILE		(RAM_INIT_FILE),
			.COMPATIBILITY		(COMPATIBILITY),
			.OUTPUT_REG			("FALSE"),
			.CHECK_FULL			(CHECK_FULL),
			.CHECK_EMPTY		(CHECK_EMPTY),
			.AFULL_THRESHOLD	(AFULL_THRESHOLD),
			.AEMPTY_THRESHOLD	(AEMPTY_THRESHOLD)
		)
		inst_dual_clock_fifo
		(
			.i_arst		(i_arst),
			.i_wclk		(i_wclk),
			.i_we		(i_we),
			.i_wdata	(i_wdata),
			.i_rclk		(i_rclk),
			.i_re		(i_re),
			.o_full		(o_full),
			.o_empty	(o_empty),
			.o_rdata	(o_rdata),
			
			.o_afull	(o_afull),
			.o_wcnt		(o_wcnt),
			.o_aempty	(o_aempty),
			.o_rcnt		(o_rcnt)
		);
	end
	else
	begin
		`IP_MODULE_NAME(dual_clock_fifo)
		#(
			.DATA_WIDTH			(DATA_WIDTH),
			.ADDR_WIDTH			(ADDR_WIDTH),
			.LATENCY			(LATENCY),
			.FIFO_MODE			(FIFO_MODE),
			.RAM_INIT_FILE		(RAM_INIT_FILE),
			.COMPATIBILITY		(COMPATIBILITY),
			.OUTPUT_REG			(OUTPUT_REG),
			.CHECK_FULL			(CHECK_FULL),
			.CHECK_EMPTY		(CHECK_EMPTY),
			.AFULL_THRESHOLD	(AFULL_THRESHOLD),
			.AEMPTY_THRESHOLD	(AEMPTY_THRESHOLD)
		)
		inst_dual_clock_fifo
		(
			.i_arst		(i_arst),
			.i_wclk		(i_wclk),
			.i_we		(i_we),
			.i_wdata	(i_wdata),
			.i_rclk		(i_rclk),
			.i_re		(i_re),
			.o_full		(o_full),
			.o_empty	(o_empty),
			.o_rdata	(o_rdata),
			
			.o_afull	(o_afull),
			.o_wcnt		(o_wcnt),
			.o_aempty	(o_aempty),
			.o_rcnt		(o_rcnt)
		);
	end
endgenerate

endmodule


/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// Dual Clock FIFO
//
//********************************
// Revisions:
// 0.0 Initial rev
// 0.1 Added read/write count, almost full, almost empty signal
//********************************

module `IP_MODULE_NAME(dual_clock_fifo)
#(
	parameter	DATA_WIDTH		= 8,
	parameter	ADDR_WIDTH		= 8,
	parameter	LATENCY			= 1,
	parameter	FIFO_MODE		= "STD_FIFO",
	parameter	RAM_INIT_FILE	= "",
	parameter	COMPATIBILITY	= "E",
	parameter	OUTPUT_REG		= "FALSE",
	parameter	CHECK_FULL		= "TRUE",
	parameter	CHECK_EMPTY		= "TRUE",
	parameter	AFULL_THRESHOLD	        = 511,
	parameter	AEMPTY_THRESHOLD= 1
)
(
	input						i_arst,
	
	input						i_wclk,
	input						i_we,
	input	[DATA_WIDTH-1:0]	i_wdata,
	
	input						i_rclk,
	input						i_re,
	
	output						o_full,
	output						o_empty,
	output	[DATA_WIDTH-1:0]	o_rdata,
	
	output						o_afull,
	output	[ADDR_WIDTH-1:0]	o_wcnt,
	output						o_aempty,
	output	[ADDR_WIDTH-1:0]	o_rcnt
);

reg		[ADDR_WIDTH:0]	r_waddrb_1P;
reg						r_wflag_1P;
reg		[ADDR_WIDTH-1:0]r_waddrg_1P;
reg		[ADDR_WIDTH-1:0]r_waddrg_2P;

reg		[ADDR_WIDTH:0]r_raddrb_wclk_1P;
reg		[ADDR_WIDTH:0]r_raddrb_wclk_neg;
reg		[ADDR_WIDTH:0]wr_cnt;

reg		[ADDR_WIDTH:0]r_waddrb_rclk_1P;
reg		[ADDR_WIDTH:0]r_waddrb_rclk_neg;
reg		[ADDR_WIDTH:0]rd_cnt;

reg						r_we_1P;
reg						r_re_1P;
reg		[ADDR_WIDTH:0]	r_raddrb_1P;
reg						r_rflag_1P;
reg		[ADDR_WIDTH-1:0]r_raddrg_1P;
reg						r_rflag_2P;
reg		[ADDR_WIDTH-1:0]r_raddrg_2P;

reg		[LATENCY-1:0]	r_empty;
reg		[LATENCY:0]		r_full;

wire	[ADDR_WIDTH:0]	w_waddrb_1P;
wire					w_wflag_1P;
wire	[ADDR_WIDTH-1:0]w_waddrg_1P;

wire	[ADDR_WIDTH:0]	w_raddrb_1P;
wire					w_rflag_1P;
wire	[ADDR_WIDTH-1:0]w_raddrg_1P;

wire	w_empty;
wire	w_full;

wire	w_empty_P;
wire	w_full_P;

wire					w_we;
wire					w_re;
wire	[ADDR_WIDTH-1:0]w_raddr;

assign	w_waddrb_1P					=	r_waddrb_1P + 1'b1;
assign	w_wflag_1P					=	w_waddrb_1P[ADDR_WIDTH];
assign	w_waddrg_1P[ADDR_WIDTH-1]	=	w_waddrb_1P[ADDR_WIDTH-1] ^ 1'b0;
assign	w_waddrg_1P[ADDR_WIDTH-2:0]	=	w_waddrb_1P[ADDR_WIDTH-2:0] ^ w_waddrb_1P[ADDR_WIDTH-1:1];

assign	w_full	=	((r_waddrg_1P == r_raddrg_1P) &
					(r_wflag_1P != r_rflag_1P))?
						1'b1:
					(i_we &
					((w_waddrg_1P == r_raddrg_2P) &
					(w_wflag_1P != r_rflag_2P)))?
						1'b1:
						1'b0;

always@(posedge i_arst or posedge i_wclk)
begin
	if (i_arst) begin
		r_raddrb_wclk_1P	<= {ADDR_WIDTH+1{1'b0}};
	end
	else begin
		r_raddrb_wclk_1P	<= r_raddrb_1P;
	end
end

always@(posedge i_arst or posedge i_wclk)
begin
	if (i_arst) begin
		r_raddrb_wclk_neg	<= {ADDR_WIDTH+1{1'b0}};
	end
	else begin
		r_raddrb_wclk_neg	<= ~r_raddrb_wclk_1P + 1'b1;
	end
end

always@(posedge i_arst or posedge i_wclk)
begin
	if (i_arst) begin
		wr_cnt			<= {ADDR_WIDTH+1{1'b0}};
	end
	else begin
		wr_cnt			<= r_waddrb_1P + r_raddrb_wclk_neg;
	end
end

always@(posedge i_arst or posedge i_rclk)
begin
	if (i_arst) begin
		r_waddrb_rclk_1P	<= {ADDR_WIDTH+1{1'b0}};
	end
	else begin
		r_waddrb_rclk_1P	<= r_waddrb_1P;
	end
end

always@(posedge i_arst or posedge i_rclk)
begin
	if (i_arst) begin
		r_waddrb_rclk_neg	<= {ADDR_WIDTH+1{1'b0}};
	end
	else begin
		r_waddrb_rclk_neg	<= ~r_waddrb_rclk_1P;
	end
end

always@(posedge i_arst or posedge i_rclk)
begin
	if (i_arst) begin
		rd_cnt			<= {ADDR_WIDTH+1{1'b0}};
	end
	else begin
		rd_cnt			<= r_raddrb_1P + r_waddrb_rclk_neg;
	end
end

always@(posedge i_arst or posedge i_wclk)
begin
	if (i_arst)
	begin
		r_we_1P			<= 1'b0;
		r_waddrb_1P		<= {ADDR_WIDTH{1'b0}};
		r_wflag_1P		<= 1'b0;
		r_waddrg_1P		<= {ADDR_WIDTH{1'b0}};
		r_waddrg_2P		<= {ADDR_WIDTH{1'b0}};
		
		r_full[0]		<= 1'b0;
	end
	else
	begin
		r_we_1P	<= 1'b0;

		if (CHECK_FULL == "TRUE")
		begin
			if (i_we & ~w_full_P)
			begin
				r_we_1P			<= 1'b1;
				r_waddrb_1P		<= w_waddrb_1P;
				r_wflag_1P		<= w_wflag_1P;
				r_waddrg_1P		<= w_waddrg_1P;
			end
		end
		else
		begin
			if (i_we)
			begin
				r_we_1P			<= 1'b1;
				r_waddrb_1P		<= w_waddrb_1P;
				r_wflag_1P		<= w_wflag_1P;
				r_waddrg_1P		<= w_waddrg_1P;
			end
		end
		
		if (r_we_1P)
			r_waddrg_2P		<= r_waddrg_1P;
		
		r_full[0]		<= w_full;
	end
end

assign	w_raddrb_1P					=	r_raddrb_1P + 1'b1;
assign	w_rflag_1P					=	w_raddrb_1P[ADDR_WIDTH];
assign	w_raddrg_1P[ADDR_WIDTH-1]	=	w_raddrb_1P[ADDR_WIDTH-1] ^ 1'b0;
assign	w_raddrg_1P[ADDR_WIDTH-2:0]	=	w_raddrb_1P[ADDR_WIDTH-2:0] ^ w_raddrb_1P[ADDR_WIDTH-1:1];

assign	w_empty	=	((r_waddrg_2P == r_raddrg_1P) &
					(r_wflag_1P == r_rflag_2P))?
						1'b1:
					(i_re &
					((r_waddrg_1P == r_raddrg_1P) &
					(r_wflag_1P == r_rflag_1P)))?
						1'b1:
						1'b0;

always@(posedge i_arst or posedge i_rclk)
begin
	if (i_arst)
	begin
		r_re_1P			<= 1'b0;
		r_raddrb_1P		<= {ADDR_WIDTH{1'b0}};
		r_rflag_1P		<= 1'b0;
		r_raddrg_1P		<= {ADDR_WIDTH{1'b0}};
		r_rflag_2P		<= 1'b0;
		r_raddrg_2P		<= {ADDR_WIDTH{1'b0}};
		
		r_empty[0]		<= 1'b1;
	end
	else
	begin
		r_re_1P	<= 1'b0;
		
		if (CHECK_FULL == "TRUE")
		begin
			if (i_re & ~w_empty_P)
			begin
				r_re_1P			<= 1'b1;
				r_raddrb_1P		<= w_raddrb_1P;
				r_rflag_1P		<= w_rflag_1P;
				r_raddrg_1P		<= w_raddrg_1P;
			end
		end
		else
		begin
			if (i_re)
			begin
				r_re_1P			<= 1'b1;
				r_raddrb_1P		<= w_raddrb_1P;
				r_rflag_1P		<= w_rflag_1P;
				r_raddrg_1P		<= w_raddrg_1P;
			end
		end
		
		if (r_re_1P)
		begin
			r_raddrg_2P		<= r_raddrg_1P;
			r_rflag_2P		<= r_rflag_1P;
		end
		
		r_empty[0]		<= w_empty;
	end
end

genvar i, j;
generate
	for (i=1; i<LATENCY; i=i+1)
	begin: pipe_empty
		always@(posedge i_arst or posedge i_rclk)
		begin
			if (i_arst)
				r_empty[i]	<= 1'b1;
			else
				r_empty[i]	<= r_empty[i-1];
		end
	end
	
	assign	w_empty_P	= w_empty | r_empty[LATENCY-1];
	
	for (j=1; j<LATENCY+1; j=j+1)
	begin: pipe_full
		always@(posedge i_arst or posedge i_wclk)
		begin
			if (i_arst)
				r_full[j]	<= 1'b0;
			else
				r_full[j]	<= r_full[j-1];
		end
	end
	
	if (COMPATIBILITY == "X")
		if (FIFO_MODE == "BYPASS")
			assign	w_full_P	= r_full[0] | r_full[LATENCY-2];
		else
			assign	w_full_P	= r_full[0]	| r_full[LATENCY];
	else
		assign	w_full_P	= r_full[0] | r_full[LATENCY-1];
	
	if (CHECK_FULL == "TRUE")
		assign	w_we	= i_we & ~w_full_P;
	else
		assign	w_we	= i_we;
	
	if (FIFO_MODE == "BYPASS")
	begin
		assign	w_re	= 1'b1;
		if (CHECK_EMPTY == "TRUE")
			assign	w_raddr	= (i_re & ~w_empty_P)?
								w_raddrg_1P[ADDR_WIDTH-1:0]:
								r_raddrg_1P[ADDR_WIDTH-1:0];
		else
			assign	w_raddr	= (i_re)?
								w_raddrg_1P[ADDR_WIDTH-1:0]:
								r_raddrg_1P[ADDR_WIDTH-1:0];
	end
	else
	begin
		if (CHECK_EMPTY == "TRUE")
			assign	w_re	= i_re & ~w_empty_P;
		else
			assign	w_re	= i_re;
		assign	w_raddr	= r_raddrg_1P[ADDR_WIDTH-1:0];
	end

	`IP_MODULE_NAME(simple_dual_port_ram)
	#(
		.DATA_WIDTH(DATA_WIDTH),
		.ADDR_WIDTH(ADDR_WIDTH),
		.OUTPUT_REG(OUTPUT_REG),
		.RAM_INIT_FILE(RAM_INIT_FILE)
	)
	inst_simple_dual_port_ram
	(
		.wdata(i_wdata),
		.waddr(r_waddrg_1P[ADDR_WIDTH-1:0]),
		.raddr(w_raddr),
		.we(w_we),
		.wclk(i_wclk),
		.re(w_re),
		.rclk(i_rclk),
		.rdata(o_rdata)
	);
endgenerate

assign	o_empty	= w_empty_P;
assign	o_full	= w_full_P;

//assign	o_aempty= w_empty_P;
assign	o_aempty= w_empty_P | (rd_cnt[ADDR_WIDTH-1] & rd_cnt[ADDR_WIDTH-2] & rd_cnt[ADDR_WIDTH-3]);
//assign	o_wcnt	= r_waddrb_1P;
assign	o_wcnt	= wr_cnt[ADDR_WIDTH] ? {ADDR_WIDTH{1'b1}} : wr_cnt[ADDR_WIDTH-1:0];
//assign	o_afull	= w_full_P;
assign	o_afull	= w_full_P | wr_cnt[ADDR_WIDTH] | (wr_cnt[ADDR_WIDTH-1] & wr_cnt[ADDR_WIDTH-2] & wr_cnt[ADDR_WIDTH-3]);
//assign	o_rcnt	= r_raddrb_1P;
assign	o_rcnt	= w_full_P ? {ADDR_WIDTH{1'b0}} : rd_cnt[ADDR_WIDTH-1:0];

endmodule


/////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2013-2019, Efinix Inc., all rights reserved.
//
// Description:
// This is EFX_SPI_LOADER_TOP to allow customer load the bitstream into SPI
// Flash.
//   

//
//
// ------------------------------------------------------------------------------
// REVISION:
// 1.0 : Initial Release
/////////////////////////////////////////////////////////////////////////////////
`resetall
`timescale 1 ps/1 ps       
//`include "dbg_defines.v"


module `IP_MODULE_NAME(efx_dbg_hub) #(
    parameter DR_WIDTH = 82
	)(
    // Xilinx BSCANE2 interface
    bscan_CAPTURE,
    bscan_DRCK,
    bscan_RESET,
    bscan_RUNTEST,
    bscan_SEL,
    bscan_SHIFT,
    bscan_TCK,
    bscan_TDI,
    bscan_TMS,
    bscan_UPDATE,
    bscan_TDO,

    // adv_dbg_if interface used in PULPino, from OpenCores
    dbg_module_selects_o,
    dbg_module_inhibit_i,
    dbg_module_tdo_i,
    dbg_data_register_o
);

    localparam ID_WIDTH = 4;
    localparam CS_WIDTH = (1 << ID_WIDTH) - 1;

    input  bscan_CAPTURE;
    input  bscan_DRCK;
    input  bscan_RESET;
    input  bscan_RUNTEST;
    input  bscan_SEL;
    input  bscan_SHIFT;
    input  bscan_TCK;
    input  bscan_TDI;
    input  bscan_TMS;
    input  bscan_UPDATE;
    output bscan_TDO;

    output  [CS_WIDTH-1:0] dbg_module_selects_o;
    input   [CS_WIDTH-1:0] dbg_module_inhibit_i;
    input   [CS_WIDTH-1:0] dbg_module_tdo_i;
    output [DR_WIDTH-1:0] dbg_data_register_o;

    reg  [DR_WIDTH-1:0] shift_register;
    wire                 hub_cmd;
    wire  [ID_WIDTH-1:0] module_id_in;
    reg   [ID_WIDTH-1:0] module_id_reg;

    wire                 select_inhibit;
    reg   [CS_WIDTH-1:0] module_selects;
    reg                  tdo_mux_o;

    assign hub_cmd             = shift_register[DR_WIDTH-1];
    assign module_id_in        = shift_register[DR_WIDTH-2 -: ID_WIDTH];
    assign dbg_data_register_o = shift_register;

    assign select_inhibit = | dbg_module_inhibit_i;

    always @(posedge bscan_TCK) begin
        if (bscan_RESET)
            shift_register <= 'h0;
        else if (bscan_SEL && bscan_SHIFT)
            shift_register <= {bscan_TDI, shift_register[DR_WIDTH-1:1]};
    end

    always @(posedge bscan_TCK) begin
        if (bscan_RESET)
            module_id_reg <= 'h0;
        else if (bscan_SEL && hub_cmd && bscan_UPDATE && !select_inhibit)
            module_id_reg <= module_id_in;
    end

    integer i;

    // one-hot select from id
    always @(*) begin
        for (i = 0; i < CS_WIDTH; i = i + 1) begin
            if (module_id_reg == i + 1)
                module_selects[i] <= 1'b1;
            else
                module_selects[i] <= 1'b0;
        end
    end

    assign dbg_module_selects_o = module_selects;

    // hard-coded 16-to-1 mux
    always @(*) begin
        case (module_id_reg) 
            'h1:     tdo_mux_o = dbg_module_tdo_i[0];
            'h2:     tdo_mux_o = dbg_module_tdo_i[1];
            'h3:     tdo_mux_o = dbg_module_tdo_i[2];
            'h4:     tdo_mux_o = dbg_module_tdo_i[3];
            'h5:     tdo_mux_o = dbg_module_tdo_i[4];
            'h6:     tdo_mux_o = dbg_module_tdo_i[5];
            'h7:     tdo_mux_o = dbg_module_tdo_i[6];
            'h8:     tdo_mux_o = dbg_module_tdo_i[7];
            'h9:     tdo_mux_o = dbg_module_tdo_i[8];
            'ha:     tdo_mux_o = dbg_module_tdo_i[9];
            'hb:     tdo_mux_o = dbg_module_tdo_i[10];
            'hc:     tdo_mux_o = dbg_module_tdo_i[11];
            'hd:     tdo_mux_o = dbg_module_tdo_i[12];
            'he:     tdo_mux_o = dbg_module_tdo_i[13];
            'hf:     tdo_mux_o = dbg_module_tdo_i[14];
            default: tdo_mux_o = 1'b0;
        endcase
    end

    assign bscan_TDO = tdo_mux_o;

endmodule


/////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2013-2019, Efinix Inc., all rights reserved.
//
// Description:
//  EFX PGM SPI is a bridge between the EFX_DBG_HUB and EFX_SPI_SHIFTER block. 
//   
//
//
// ------------------------------------------------------------------------------
// REVISION:
// 1.0 Initial Release
/////////////////////////////////////////////////////////////////////////////////
`resetall
`timescale 1 ps/1 ps
  
//Internal Register Address of the Configured SPI Controller
`define INTREG_CORE_ID0            9'h00 
`define INTREG_CORE_ID1            9'h55
`define INTREG_TEST0               9'hAA
`define INTREG_TEST1               9'h7F    
`define INTREG_FPGA_ID             9'h7E
`define INTREG_WFIFO0              9'h01 //Lower 8 bit of WFIFO Depth
`define INTREG_WFIFO1              9'h02 //Upper 8 bit of WFIFO Depth
`define INTREG_RFIFO0              9'h03 //Lower 8 bit of RFIFO Depth
`define INTREG_RFIFO1              9'h04 //Upper 8 bit of RFIFO Depth
`define INTREG_IP_STATUS           9'h05
`define INTREG_IP_CMD              9'h06 //SPI Flash Command Instructions
`define INTREG_SPI_FLASH_ADDR_0    9'h07 
`define INTREG_SPI_FLASH_ADDR_1    9'h08
`define INTREG_SPI_FLASH_ADDR_2    9'h09
`define INTREG_SPI_FLASH_ADDR_3    9'h0A
`define INTREG_CONFIG_USR_CHANNEL  9'h0B
`define INTREG_CONFIG_SCLK         9'h0C
`define INTREG_IP_INSTR            9'h0D //SPI Flash Command Instructions
`define INTREG_WFIFO_BURST_SIZE    9'h0E
`define INTREG_RFIFO_BURST_SIZE    9'h0F
`define INTREG_WBURST_JT_DLY       9'h10 //JTAG Chain Delay During Write Burst.


//EFX SPI SHIFTER CTL Register.
`define INTREG_SPI_FLASH_DUAL_MODE 9'hFD
`define INTREG_SPI_FLASH_SELECT 9'hFE
//EFX SPI SHIFTER CTL Register. 
`define INTREG_CONFIG_RW_START 9'hFF
//SPI MASTER STATUS REGISTERS
`define INTREG_SPI_FSM_STAT    9'h100
`define INTREG_SPI_MF_ID       9'h101
`define INTREG_SPI_DEVICE_ID   9'h102
`define INTREG_SPI_JEDEC_ID0   9'h103
`define INTREG_SPI_JEDEC_ID1   9'h104
`define INTREG_SPI_UNIQ_ID0    9'h105
`define INTREG_SPI_UNIQ_ID1    9'h106
`define INTREG_SPI_UNIQ_ID2    9'h107
`define INTREG_SPI_UNIQ_ID3    9'h108
`define INTREG_SPI_UNIQ_ID4    9'h109
`define INTREG_SPI_UNIQ_ID5    9'h10A
`define INTREG_SPI_UNIQ_ID6    9'h10B
`define INTREG_SPI_UNIQ_ID7    9'h10C
`define INTREG_SPI_RD_STATUS0  9'h10D
`define INTREG_SPI_RD_STATUS1  9'h10E
`define INTREG_SPI_RD_STATUS2  9'h10F
`define INTREG_SPI_WR_STATUS0  9'h110
`define INTREG_SPI_WR_STATUS1  9'h111
`define INTREG_SPI_WR_STATUS2  9'h112
`define INTREG_SPI_JEDEC_ID2   9'h113
`define INTREG_SPI_WR_NONVOLATILE_CONFIG    9'h114
`define INTREG_SPI_RD_NONVOLATILE_CONFIG    9'h115
`define INTREG_SPI_WR_NONVOLATILE1_CONFIG   9'h116
`define INTREG_SPI_RD_NONVOLATILE1_CONFIG   9'h117
`define INTREG_SPI_WR_STATUS0_16B   9'h118

////JUST ADDED



module `IP_MODULE_NAME(efx_pgm_spi)
#(
    parameter WFIFO_DEPTH_256 = 8'd60,
    parameter RFIFO_DEPTH_256 = 8'd60,    
	parameter DR_WIDTH = 82,
	parameter FPGA_ID = 8'd1
)
   (
    input clkin,
    output reg JTAG_lock,
    input JTAG_locked,  
    
    //Status
    input wfifo_empty,
    input rfifo_full,
    input rfifo_empty,
    //spi readback.
    input [23:0] jedec_id_reg,
    input [7:0] manufacturing_id_reg,
    input [63:0] unique_id_reg,
    input [7:0] device_id_reg,
    input [7:0] spi_flash_rd_status_reg0,
    input [7:0] spi_flash_rd_status_reg1,
    input [7:0] spi_flash_rd_status_reg2,
    input [15:0] spi_flash_rd_nonvolatile_config,
    input erase_en,
    input [4:0] fsm_status,
    input page_program_done,
    
     ////add fourbyte_addr_enable
   // input fourbyte_addr_enable, //fourbyte_addr_enable,
    
    // JTAG
    input bscan_CAPTURE,
    input bscan_DRCK,
    input bscan_RESET,
    input bscan_RUNTEST,
    input bscan_SEL,
    input bscan_SHIFT,
    input bscan_TCK,
    input bscan_TDI,
    input bscan_TMS,
    input bscan_UPDATE,
    
    // advanced debug interface - 
    input dbg_module_select_i,
    output reg dbg_module_inhibit_o,
    output reg dbg_module_tdo_o,
    input [DR_WIDTH-1:0] dbg_data_register_i,
    
    //Burst Data Interface
    output burst_data_wr_valid,
    output wire [7:0] burst_data_wr,
    output wire rfifo_rd_en,
    input [7:0] data_from_fifo,

    output reg [7:0] w_burst_size,
    output reg [7:0] r_burst_size,
    
    output reg [15:0] wr_nonvolatile_config,
    //SPI Flash Interface
    output reg [4:0] spi_cmd_out,
    output wire spi_cmd_en_out, 
    output reg  spi_flash_select,
    output reg  spi_flash_dual_mode,
    output wire [31:0] spi_flash_addr_out,
    output reg [7:0]   spi_wdata,
    output reg [15:0]  status_reg_16B,
    output reg [7:0]   spi_cmd_instr                     //this is 8-bit command instruction. 
    );
   
//localparam DR_WIDTH = 53;	// DR_WIDTH >= 1+ OP_WIDTH+ ADDR_WIDTH+ COUNT_WIDTH, in spec =37
localparam OP_WIDTH = 4;
localparam ADDR_WIDTH = 32;
localparam COUNT_WIDTH = 16;
localparam REGSEL_WIDTH = 9;
localparam REG_WIDTH = 8;
localparam REG_16B_WIDTH = 16;

localparam REG_MSB = DR_WIDTH - 2 - OP_WIDTH - REGSEL_WIDTH;

/*localparam INT_DEPTH = ((INT_WIDTH-1)/REG_WIDTH) + 1;
localparam OUT_DEPTH = ((OUT_WIDTH-1)/REG_WIDTH) + 1;
localparam INT_DEPTH_LOG2 = clog2(INT_DEPTH);
localparam OUT_DEPTH_LOG2 = clog2(OUT_DEPTH);*/

   //This is 8-bit version 
   localparam INTREG0_SPI_FSM_STAT  = 8'h00;
   localparam INTREG0_SPI_MF_ID     = 8'h01;
   localparam INTREG0_SPI_DEVICE_ID = 8'h02;
   localparam INTREG0_SPI_JEDEC_ID0 = 8'h03;
   localparam INTREG0_SPI_JEDEC_ID1 = 8'h04;
   localparam INTREG0_SPI_UNIQ_ID0  = 8'h05;
   localparam INTREG0_SPI_UNIQ_ID1  = 8'h06;
   localparam INTREG0_SPI_UNIQ_ID2  = 8'h07;
   localparam INTREG0_SPI_UNIQ_ID3  = 8'h08;
   localparam INTREG0_SPI_UNIQ_ID4  = 8'h09;
   localparam INTREG0_SPI_UNIQ_ID5  = 8'h0A;
   localparam INTREG0_SPI_UNIQ_ID6  = 8'h0B;
   localparam INTREG0_SPI_UNIQ_ID7  = 8'h0C;
   localparam INTREG0_SPI_RD_STATUS0 = 8'h0D;
   localparam INTREG0_SPI_RD_STATUS1 = 8'h0E;
   localparam INTREG0_SPI_RD_STATUS2 = 8'h0F;
   localparam INTREG0_SPI_WR_STATUS0 = 8'h10;
   localparam INTREG0_SPI_WR_STATUS1 = 8'h11;
   localparam INTREG0_SPI_WR_STATUS2 = 8'h12;
   localparam INTREG0_SPI_WR_NONVOLATILE_CONFIG = 8'h14;
   localparam INTREG0_SPI_RD_NONVOLATILE_CONFIG = 8'h15;
   localparam INTREG0_SPI_WR_16B_STATUS = 8'h18;
   
   
   
// Cmd coding for instructions
// This part defines what firmware instruct the type of instructions (opcode) 
localparam VIO_CMD_BWRITE8  = 4'h1;         //Burst Write
localparam VIO_CMD_BWRITE16 = 4'h2;
//localparam VIO_CMD_BWRITE32 = 4'h3;
//localparam VIO_CMD_BWRITE64 = 4'h4;
localparam VIO_CMD_BREAD8   = 4'h5;        //Burst Read
localparam VIO_CMD_BREAD16  = 4'h6;
//localparam VIO_CMD_BREAD32  = 4'h7;
//localparam VIO_CMD_BREAD64  = 4'h8;
localparam VIO_CMD_IREG_WR  = 4'h9;         //Single Write 
localparam VIO_CMD_IREG_SEL = 4'hd;         //Single Read

// FSM state coding
//== State enumeration 
parameter [3:0] // synopsys enum state_info 
	     STATE_idle    = 4'h0,
	     STATE_Rbegin  = 4'h1, 
	     STATE_Rready  = 4'h2,
	     STATE_Rstatus = 4'h3,
	     STATE_Rburst  = 4'h4,
	     STATE_Wready  = 4'h5,
	     STATE_Wwait   = 4'h6,
	     STATE_Wburst  = 4'h7,
	     STATE_Wstatus = 4'h8,
	     STATE_Rcrc    = 4'h9,
	     STATE_Wcrc    = 4'ha, 
	     STATE_Wmatch  = 4'hb,
	     STATE_Wwait_dly = 4'hc;

   //== State viariables 
   reg [3:0] 	       /* synopsys enum state_info */
		       module_state;		/* synopsys state_vector state_r */
   reg [3:0] 	       /* synopsys enum state_info */
		       module_next_state;

// Registers to hold state etc.
//reg [2:0] internal_reg_r0;          // module internal register.
reg [REG_WIDTH-1:0] data_out_shift_reg;       // widht-bits to accomodate the internal_reg_*
reg [REGSEL_WIDTH-1:0] internal_register_select; // Holds index of currently selected register
reg [OP_WIDTH-1:0] opcode;                   // holds the current command (rd/wr, word size)
reg [31:0] address_counter;          // Holds address for next Wishbone access
reg [5:0] bit_count;                // How many bits have been shifted in/out
reg [15:0] word_count;               // bytes remaining in current burst command

// Control signals for the various counters / registers / state machines
reg out_reg_ld_en;    // Enable parallel load of data_out_shift_reg
reg out_reg_shift_en; // Enable shift of data_out_shift_reg
reg out_reg_data_sel; // 0 = BIU data, 1 = internal register data
reg regsel_ld_en;     // Reg. select register load enable
reg intreg_ld_en;     // load enable for internal registers
reg [1:0] tdo_output_sel;   // Selects signal to send to TDO.  0 = ready bit, 1 = output register, 2 = CRC match, 3 = CRC shift reg.
reg addr_sel;         // Selects data for address_counter. 0 = data_register_i, 1 = incremented address count
reg addr_ct_en;       // Enable signal for address counter register
reg op_reg_en;        // Enable signal for 'operation' register
reg bit_ct_rst;       // reset (zero) bit count register
reg bit_ct_en;        // enable bit counter
reg word_ct_sel;      // Selects data for byte counter.  0 = data_register_i, 1 = decremented byte count
reg word_ct_en;       // Enable byte counter register
reg crc_in_sel;       // selects incoming write data (=0) or outgoing read data (=1)as input to CRC module
reg crc_en;           // does 1-bit iteration in CRC module
reg crc_shift_en;     // CRC reg is also it's own output shift register; this enables a shift
reg crc_clr;          // resets CRC module
reg biu_strobe;       // Indicates that the bus unit should latch data and start a transaction

// Status signals
wire intreg_instruction; // True when the input_data_i reg has a valid internal register instruction
wire intreg_write;       // True when the input_data_i reg has an internal register write op
wire burst_write;        // True when the input_data_i reg has a valid burst write instruction for this module
wire burst_read;         // True when the input_data_i reg has a valid burst read  instruction for this module 
reg rd_op;              // True when operation in the opcode reg is a read, false when a write
wire bit_count_max;      // true when bit counter is equal to current word size
wire bit_count_32;       // true when bit count register == 32, for CRC after burst writes
wire word_count_zero;    // true when byte counter is zero
wire crc_match;          // indicates whether data_register_i matches computed CRC
wire biu_ready;          // indicates that the BIU has finished the last command
    
// Intermediate signals
wire module_cmd;             // inverse of MSB of data_register_i. 1 means current cmd not for top level (but is for us)
wire [OP_WIDTH-1:0] opcode_in;              // from data_register_i
wire [ADDR_WIDTH-1:0] address_in;             // from data_register_i
wire [COUNT_WIDTH-1:0] count_in;               // from data_register_i
wire [REGSEL_WIDTH-1:0] reg_select;             // from data_register_i, input to internal register select register

wire [REG_WIDTH-1:0] out_reg_data;           // parallel input to the output shift register
reg [REG_WIDTH-1:0] data_from_internal_reg; // data from internal reg. MUX to output shift register
reg [5:0] word_size_bits;         // 8,16,32 or 64.  Decoded from 'operation'
reg [3:0] word_size_bytes;        // 1,2,4 or 8
wire [31:0] data_to_addr_counter;   // output of the mux in front of the address counter inputs
wire [32:0] incremented_address;    // value of address counter plus 'word_size'
wire [15:0] decremented_word_count;
wire [15:0] data_to_word_counter;   // output of the mux in front of the byte counter input
wire crc_serial_out;
wire crc_data_in;            // input to CRC module, either data_register_i[52] or data_out_shift_reg[0]
wire [31:0] crc_data_out;           // output of CRC module, to output shift register
wire [REG_WIDTH-1:0] data_to_biu;            // from data_register_i
   
   reg [7:0] 	     burst_data_w;
   reg [7:0] 	     jtag_chain_wburst_dly;
   reg [7:0] wwait_dly_cnt;
   reg 	     wwait_dly_cnt_en;
   wire      commit_int;
   wire      clear_int;

   //Internal Signals for registers. 
   reg [7:0] test0;
   reg [7:0] test1;
   reg [4:0] spi_flash_cmd;
   reg 	     spi_trigger;
   reg [7:0] spi_flash_addr0;
   reg [7:0] spi_flash_addr1;
   reg [7:0] spi_flash_addr2;
   reg [7:0] spi_flash_addr3;
   wire      slow_clk_en;
  
   wire [1:0] spi_io_width;
   wire [1:0] spi_addr_width;
   wire [1:0] user_channel;
   reg [7:0]  sclk_div;
  
   reg 	       spi_cmd_en;
   
   reg 	       burst_read0;
   reg 	       burst_read1;
   wire [7:0] wr_data_reg;
   wire [15:0] wr_data_16B_reg;
   reg [7:0]  spi_api_cmd;
   
function integer clog2;
input integer value;
integer d;
begin
	if (value <= 0)
        	clog2 = 0;
	else begin
        	d = 2;
                for (clog2 = 1; d < value; clog2 = clog2 + 1)
                    d = d << 1;
        	end
        end
endfunction

//Current block is in use if active.    
assign module_cmd  = ~dbg_data_register_i[DR_WIDTH-1];
//4-bits OPCODE
assign opcode_in   =  dbg_data_register_i[DR_WIDTH-2 -: OP_WIDTH];
//32-bits ADDRESS 
assign address_in  =  dbg_data_register_i[DR_WIDTH-2-OP_WIDTH -: ADDR_WIDTH];
//16-bits COUNT
assign count_in    =  dbg_data_register_i[DR_WIDTH-2-OP_WIDTH-ADDR_WIDTH -: COUNT_WIDTH];
//9-bits REGSEL
assign reg_select  =  dbg_data_register_i[DR_WIDTH-2-OP_WIDTH -: REGSEL_WIDTH];
//NA. 
assign data_to_biu = {bscan_TDI, dbg_data_register_i[DR_WIDTH-1 -: REG_WIDTH-1]};
//assign {hold_probe_in, clear_int, commit_int} = internal_reg_r0[0 +: 3];


//Internal register instruction  (IREG_SEL / IREG_WR)
assign intreg_instruction = ((opcode_in == VIO_CMD_IREG_WR) | (opcode_in == VIO_CMD_IREG_SEL));
//Internal register write command
assign intreg_write = (opcode_in == VIO_CMD_IREG_WR);
//Define the burst write command.   
assign burst_write =  (opcode_in == VIO_CMD_BWRITE8)  | 
                      (opcode_in == VIO_CMD_BWRITE16) ; 
                      //(opcode_in == VIO_CMD_BWRITE32) | 
                      //(opcode_in == VIO_CMD_BWRITE64)
//Define the burst read command.
assign burst_read  =  (opcode_in == VIO_CMD_BREAD8)  | 
                      (opcode_in == VIO_CMD_BREAD16) ; 
                      //(opcode_in == VIO_CMD_BREAD32) | 
                      //(opcode_in == VIO_CMD_BREAD64) 


   
    always @(posedge bscan_TCK) 
      if (bscan_RESET) begin 
	 burst_read0 <= 1'b0;
	 burst_read1 <= 1'b0;
      end

      else if ( word_count == {r_burst_size,8'h00} )
	begin
	   burst_read0 <= burst_read;
	   burst_read1 <= burst_read0;
	end
     // else if ( (word_count == 16'd256 & r_burst_size== 8'h01)  ||
     //(word_count == 16'd512 & r_burst_size== 8'h02)  ||
     //	(word_count == 16'd2560 & r_burst_size== 8'ha)  ||
     //	(word_count == 16'd5120 & r_burst_size== 8'd20) ||
     //	(word_count == 16'd15360 & r_burst_size== 8'd60) ||
     //	(word_count == 16'd25600 & r_burst_size== 8'd100)
     //	) begin 


      else if (word_count_zero) begin
      	 burst_read0 <= 1'b0;
      	 burst_read1 <= 1'b0;
      end
   

       
       
   //////////////////////////////////////////////////////////
   //Based on burst read/write command,
   //define the word_size_bits, word_size_bytes, rd_op.
   ///////////////////////////////////////////////////////////
   always @(*) begin
      case (opcode)

	//BURST WRITE 8/16/32/64
        VIO_CMD_BWRITE8: begin
           word_size_bits  = 6'd7;  // Bits is actually bits-1, to make the FSM easier
           word_size_bytes = 4'd1;
           rd_op           = 1'b0;
        end
        VIO_CMD_BWRITE16: begin
           word_size_bits  = 6'd15;  // Bits is actually bits-1, to make the FSM easier
           word_size_bytes = 4'd2;
           rd_op           = 1'b0;
        end
	
        //VIO_CMD_BWRITE32: begin
        //    word_size_bits  = 6'd31;  // Bits is actually bits-1, to make the FSM easier
        //    word_size_bytes = 4'd4;
        //    rd_op           = 1'b0;
        //end
        //VIO_CMD_BWRITE64: begin
        //    word_size_bits  = 6'd63;  // Bits is actually bits-1, to make the FSM easier
        //    word_size_bytes = 4'd8;
        //    rd_op           = 1'b0;
        //end


	//Burst Read 8/16/32/64
        VIO_CMD_BREAD8: begin
           word_size_bits  = 6'd7;  // Bits is actually bits-1, to make the FSM easier
           word_size_bytes = 4'd1;
           rd_op           = 1'b1;
        end
        VIO_CMD_BREAD16: begin
           word_size_bits  = 6'd15;  // Bits is actually bits-1, to make the FSM easier
           word_size_bytes = 4'd2;
           rd_op           = 1'b1;
        end
        //VIO_CMD_BREAD32: begin
        //    word_size_bits  = 6'd31;  // Bits is actually bits-1, to make the FSM easier
        //    word_size_bytes = 4'd4;
        //    rd_op           = 1'b1;
        //end
        //VIO_CMD_BREAD64: begin
        //    word_size_bits  = 6'd63;  // Bits is actually bits-1, to make the FSM easier
        //    word_size_bytes = 4'd4;
        //    rd_op           = 1'b1;
        //end
	
        default: begin
           word_size_bits  = 6'b00_0000;
           word_size_bytes = 4'b0000;
           rd_op           = 1'b0;
        end
      endcase // case (opcode)
   end // always @ (*)
   
   
////////////////////////////////////////
// Internal register
// This is internal register map in
// EFX PGM SPI. 
////////////////////////////////////////

//9-bits internal register select
always @(posedge bscan_TCK) 
  begin
     if (bscan_RESET)
       internal_register_select <= 'h0;
     else if (regsel_ld_en)
       internal_register_select <= reg_select;
  end


  
   
 
//Read Registers
always @(*) 
  begin
     case (internal_register_select)
//       `INTREG_CORE_ID0: data_from_internal_reg = internal_reg_r0;

       `INTREG_CORE_ID0  : data_from_internal_reg = 8'hF0;  //ID0
       `INTREG_CORE_ID1  : data_from_internal_reg = 8'hA5;  //ID1
       `INTREG_TEST0     : data_from_internal_reg = test0;  //Test Register 0
       `INTREG_TEST1     : data_from_internal_reg = test1;  //Test Register 1
       `INTREG_WFIFO0    : data_from_internal_reg = WFIFO_DEPTH_256 ; //WFIFO DEPTH - 0x01 - 256 Byte
       `INTREG_WFIFO1    : data_from_internal_reg = 8'h00; //WFIFO DEPTH
       `INTREG_RFIFO0    : data_from_internal_reg = RFIFO_DEPTH_256 ; //RFIFO DEPTH - 0x01 - 256 Byte
       `INTREG_RFIFO1    : data_from_internal_reg = 8'h00; //RFIFO DEPTH
       `INTREG_IP_STATUS : data_from_internal_reg = { 3'b0,rfifo_full,rfifo_empty,wfifo_empty,JTAG_locked,JTAG_lock};
       `INTREG_IP_CMD    : data_from_internal_reg = { spi_trigger, 2'b0, spi_flash_cmd[4:0]};
       `INTREG_SPI_FLASH_ADDR_0 : data_from_internal_reg = spi_flash_addr0;
       `INTREG_SPI_FLASH_ADDR_1 : data_from_internal_reg = spi_flash_addr1;
       `INTREG_SPI_FLASH_ADDR_2 : data_from_internal_reg = spi_flash_addr2;
       `INTREG_SPI_FLASH_ADDR_3 : data_from_internal_reg = spi_flash_addr3;
       `INTREG_CONFIG_USR_CHANNEL : data_from_internal_reg = {slow_clk_en,erase_en,spi_io_width,spi_addr_width,user_channel};
       `INTREG_CONFIG_SCLK : data_from_internal_reg = sclk_div;
       `INTREG_IP_INSTR  : data_from_internal_reg = spi_cmd_instr;
       `INTREG_WFIFO_BURST_SIZE : data_from_internal_reg = w_burst_size;   
       `INTREG_RFIFO_BURST_SIZE : data_from_internal_reg = r_burst_size;
       `INTREG_WBURST_JT_DLY : data_from_internal_reg = jtag_chain_wburst_dly; 
       `INTREG_FPGA_ID     : data_from_internal_reg = FPGA_ID;  //Test Register 0
       
       
       //SPI Command Index (1xx) 
       `INTREG_SPI_FSM_STAT : data_from_internal_reg = {page_program_done,2'b0,fsm_status[4:0]};

       `INTREG_SPI_MF_ID     : data_from_internal_reg = manufacturing_id_reg;
       `INTREG_SPI_DEVICE_ID : data_from_internal_reg = device_id_reg;
       `INTREG_SPI_JEDEC_ID0 : data_from_internal_reg = jedec_id_reg[7:0];
       `INTREG_SPI_JEDEC_ID1 : data_from_internal_reg = jedec_id_reg[15:8];
       `INTREG_SPI_JEDEC_ID2 : data_from_internal_reg = jedec_id_reg[23:16];
       `INTREG_SPI_UNIQ_ID0  : data_from_internal_reg = unique_id_reg[7:0];
       `INTREG_SPI_UNIQ_ID1  : data_from_internal_reg = unique_id_reg[15:8];
       `INTREG_SPI_UNIQ_ID2  : data_from_internal_reg = unique_id_reg[23:16];
       `INTREG_SPI_UNIQ_ID3  : data_from_internal_reg = unique_id_reg[31:24];
       `INTREG_SPI_UNIQ_ID4  : data_from_internal_reg = unique_id_reg[39:32];
       `INTREG_SPI_UNIQ_ID5  : data_from_internal_reg = unique_id_reg[47:40];
       `INTREG_SPI_UNIQ_ID6  : data_from_internal_reg = unique_id_reg[55:48];
       `INTREG_SPI_UNIQ_ID7  : data_from_internal_reg = unique_id_reg[63:56];
       `INTREG_SPI_RD_STATUS0 : data_from_internal_reg = spi_flash_rd_status_reg0;
       `INTREG_SPI_RD_STATUS1 : data_from_internal_reg = spi_flash_rd_status_reg1;
       `INTREG_SPI_RD_STATUS2 : data_from_internal_reg = spi_flash_rd_status_reg2;
       `INTREG_SPI_RD_NONVOLATILE_CONFIG : data_from_internal_reg = spi_flash_rd_nonvolatile_config[7:0];
       `INTREG_SPI_RD_NONVOLATILE1_CONFIG : data_from_internal_reg = spi_flash_rd_nonvolatile_config[15:8];
       //To write the status register , not read the status register. 
 //      `INTREG_SPI_WR_STATUS0 : data_from_internal_reg = spi_flash_wr_status_reg0;
 //      `INTREG_SPI_WR_STATUS1 : data_from_internal_reg = spi_flash_wr_status_reg1;
 //      `INTREG_SPI_WR_STATUS2 : data_from_internal_reg = spi_flash_wr_status_reg2;
       
       default:   data_from_internal_reg = 8'h0;
     endcase
  end // always @ (*)



   //////////////////////////////////////////////////////////////////
   //Temporary Assign to 0. Will connect to SPI Flash I/F, which
   //execute the command and return the required id.
   //////////////////////////////////////////////////////////////////

   
  
   assign slow_clk_en = 1'b0;
   
   assign user_channel = 2'b01;   //SPI
   assign spi_addr_width = 2'b10; //24-bits ADDRESSING
   assign spi_io_width = 2'b00;   //x1
   

   
   
//////////////////////////////////////   
//Write Registers
//////////////////////////////////////
   
   
   assign wr_data_reg = dbg_data_register_i[REG_MSB -: 8] ;
   assign wr_data_16B_reg = dbg_data_register_i[REG_MSB -: REG_16B_WIDTH] ;
   
   assign burst_data_wr = dbg_data_register_i[(DR_WIDTH - 2) -: 8]; //default 

   
   always @(posedge bscan_TCK) begin
      if (bscan_RESET)
	begin  
       test0 <= 8'h00;
	   test1 <= 8'h00;
	   JTAG_lock <= 1'b0;
	   spi_flash_cmd <= 5'h0;
	   spi_trigger <= 1'b0;
	   spi_flash_addr0 <= 8'h0;
	   spi_flash_addr1 <= 8'h0;
	   spi_flash_addr2 <= 8'h0;
	   spi_flash_addr3 <= 8'h0;
	   sclk_div <= 8'h00;
	   spi_api_cmd <= 8'h0;
	   spi_wdata <= 8'h0;
	   status_reg_16B <= 16'h0;
	   spi_cmd_en <= 1'b0;
	   spi_flash_select <= 1'b0;
	   spi_cmd_instr <= 8'h00;
	   w_burst_size <= 8'h01;  // default : 0x01 - 256 Bytes
	   r_burst_size <= 8'h01;  // default : 0x01 - 256 Bytes
	   jtag_chain_wburst_dly <= 8'h00;
	   wr_nonvolatile_config <= 16'h0;
	   spi_flash_dual_mode <= 1'b1;

	end
      
      else if (intreg_ld_en /*&& (reg_select == `INTREG_R0)*/) begin
	case (reg_select)
	  `INTREG_TEST0 : test0 <= wr_data_reg[7:0];
	  `INTREG_TEST1 : test1 <= wr_data_reg[7:0];
	  `INTREG_IP_STATUS : JTAG_lock <= wr_data_reg[0];
	  `INTREG_IP_CMD    : 
	    begin
	       spi_flash_cmd <= wr_data_reg[4:0];
	       spi_trigger   <= wr_data_reg[7];
	       
	       spi_api_cmd <= {4'b0011,wr_data_reg[3:0]};
	       spi_cmd_en  <= wr_data_reg[7];  
	    end

	  `INTREG_IP_INSTR  :
	    begin
	       spi_cmd_instr <= wr_data_reg[7:0];
	    end

	  `INTREG_WFIFO_BURST_SIZE : w_burst_size <= wr_data_reg[7:0];
	  `INTREG_RFIFO_BURST_SIZE : r_burst_size <= wr_data_reg[7:0];
	  `INTREG_WBURST_JT_DLY    : jtag_chain_wburst_dly <= wr_data_reg[7:0];
	  `INTREG_SPI_FLASH_ADDR_0 : spi_flash_addr0 <= wr_data_reg[7:0];
	  `INTREG_SPI_FLASH_ADDR_1 : spi_flash_addr1 <= wr_data_reg[7:0];
	  `INTREG_SPI_FLASH_ADDR_2 : spi_flash_addr2 <= wr_data_reg[7:0];
	  `INTREG_SPI_FLASH_ADDR_3 : spi_flash_addr3 <= wr_data_reg[7:0];
	  `INTREG_CONFIG_SCLK      : sclk_div        <= wr_data_reg[7:0];
	  `INTREG_CONFIG_RW_START  : spi_cmd_en      <= wr_data_reg[0];
	  //use this signal to indicates which flash to write the spi api command
	  //1st flash => spi_flash_select = 0
	  //2nd flash => spi_flash_select = 1
	  `INTREG_SPI_FLASH_SELECT : spi_flash_select <= wr_data_reg[0];
     //IF paramter ENABLE_DUAL_FLASH=1 and spi_flash_dual_mode=1, 
     //--- burst write data to both flash
     //IF paramter ENABLE_DUAL_FLASH=1 and spi_flash_dual_mode=0, 
     //--- burst write data to either lower or upper flash based on spi_flash_select
     `INTREG_SPI_FLASH_DUAL_MODE : spi_flash_dual_mode <= wr_data_reg[0];
	  //SPI Flash Command 
	  `INTREG_SPI_MF_ID : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_DEVICE_ID : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_JEDEC_ID0 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_JEDEC_ID1 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID0 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID1 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID2 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID3 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID4 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID5 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID6 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_UNIQ_ID7 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  
	  `INTREG_SPI_RD_STATUS0 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_RD_STATUS1 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_RD_STATUS2 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_WR_STATUS0 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_WR_STATUS1 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  `INTREG_SPI_WR_STATUS2 : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end

	  `INTREG_SPI_WR_NONVOLATILE_CONFIG : begin 
	     spi_api_cmd                  <= reg_select[7:0];     //Store the SPI Command 
	     wr_nonvolatile_config[7:0]   <= wr_data_reg[7:0];    //Writing to NONVOLATILE CONFIGURATION register
	                                                          //byte 0
	  end

	  `INTREG_SPI_WR_NONVOLATILE1_CONFIG : begin 
	     spi_api_cmd                   <= reg_select[7:0];     //Store the SPI Command 
	     wr_nonvolatile_config[15:8]   <= wr_data_reg[7:0];    //Writing to NONVOLATILE CONFIGURATION register
	                                                           //byte 1
	  end

	  `INTREG_SPI_RD_NONVOLATILE_CONFIG : begin 
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command 
	     spi_wdata       <= wr_data_reg[7:0];    //Store the SPI Write Data. 
	  end
	  
	  `INTREG_SPI_WR_STATUS0_16B : begin
	     spi_api_cmd     <= reg_select[7:0];     //Store the SPI Command  //INTREG0_SPI_WR_16B_STATUS
	     status_reg_16B  <= wr_data_16B_reg;    //Store the SPI Write Data. 
	  end
	  

	  default : ;
	endcase // case (reg_select)
      end
   end // always @ (posedge bscan_TCK)

  
   
   
   //Interface to SPI Flash Controller
   
   ///////////////////////////////////////////////
   // command interface - spi_cmd
   ///////////////////////////////////////////////
    //1 soft_reset,         // soft reset. 
    //2 read,               // read 
    //3 read_device_id,     // read device id
    //4 read_unique_id,     // read unique id
    //5 read_reg,	    // read status register 1/2/3; data_in as command
    //6 read_jedec_id,      // read jedec id.
    //8 write_enable,	    // write enable (0x06), write disable (0x04), write enable vsr (0x50); data_in as command
    //9 write_reg1,	    // write status register 1
    //10 write_reg2,	    // write status register 2
    //11 write_reg3,	    // write status register 3 
    //12 write,             // Page Program 
    //13 erase,             // Ease
    //14 read_reg1          // read status register 1
    //15 read_reg2          // read status register 2
    //16 read_reg3          // read status register 3
    //17 read_manufacturing_id // read manufacturing id.
   
  
   always @(*)
     begin
	case (spi_api_cmd)
	  INTREG0_SPI_MF_ID :      spi_cmd_out = 5'd17;
	  INTREG0_SPI_DEVICE_ID :  spi_cmd_out = 5'd3; 
	  INTREG0_SPI_JEDEC_ID0 :  spi_cmd_out = 5'd6;
	  INTREG0_SPI_JEDEC_ID1 :  spi_cmd_out = 5'd6;
	  INTREG0_SPI_UNIQ_ID0  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_UNIQ_ID1  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_UNIQ_ID2  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_UNIQ_ID3  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_UNIQ_ID4  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_UNIQ_ID5  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_UNIQ_ID6  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_UNIQ_ID7  :  spi_cmd_out = 5'd4;
	  INTREG0_SPI_RD_STATUS0 : spi_cmd_out = 5'd14;
	  INTREG0_SPI_RD_STATUS1 : spi_cmd_out = 5'd15;
	  INTREG0_SPI_RD_STATUS2 : spi_cmd_out = 5'd16;
	  INTREG0_SPI_WR_STATUS0 : spi_cmd_out = 5'd9;
	  INTREG0_SPI_WR_STATUS1 : spi_cmd_out = 5'd10;
	  INTREG0_SPI_WR_STATUS2 : spi_cmd_out = 5'd11;
	  INTREG0_SPI_WR_NONVOLATILE_CONFIG : spi_cmd_out = 5'd21;
	  INTREG0_SPI_RD_NONVOLATILE_CONFIG : spi_cmd_out = 5'd22;
	  8'h31 : spi_cmd_out = 5'd1;    //Reset
	  8'h32 : spi_cmd_out = 5'd2;    //Read
	  8'h33 : spi_cmd_out = 5'd8;    //Write Enable 
	  8'h34 : spi_cmd_out = 5'd18;   //WRite Enable for volatile status
	  8'h35 : spi_cmd_out = 5'd19;   //Write disable
	  8'h36 : spi_cmd_out = 5'd3;    //Release Power Down & Device ID (8'hAB) - 16M -0x14, 32M -0x15
	  8'h3c : spi_cmd_out = 5'd12;   //Write 
	  8'h3d : spi_cmd_out = 5'd13;   //Erase
      

	  
	  8'h3A: spi_cmd_out = 5'd26;  //Enter_4BYTE ADDRESS (8'hB7)
	  8'h3B: spi_cmd_out = 5'd27;  //Exit_4BYTE ADDRESS (8'hE9)
       // 8'h3E: spi_cmd_out = 5'd29;  //ENTER OR EXIT 4 BYTE
     

	  INTREG0_SPI_WR_16B_STATUS : spi_cmd_out = 5'd23;
	  default : spi_cmd_out = 5'd0;
	  
	endcase // case (internal_register_select)
	
     end

   assign spi_flash_addr_out[31:0] = {spi_flash_addr3,spi_flash_addr2,spi_flash_addr1,spi_flash_addr0};
   assign spi_cmd_en_out = spi_cmd_en;
   


///////////////////////////////////////////////
// Address counter

assign data_to_addr_counter = (addr_sel) ? incremented_address[31:0] : address_in;
assign incremented_address  = address_counter + word_size_bytes;

// Technically, since this data (sometimes) comes from the input shift reg, we should latch on
// negedge, per the JTAG spec. But that makes things difficult when incrementing.
always @(posedge bscan_TCK) begin // JTAG spec specifies latch on negative edge in UPDATE_DR state
	if (bscan_RESET)
            address_counter <= 32'h0;
        else if (addr_ct_en)
            address_counter <= data_to_addr_counter;
end

////////////////////////////////////////
// Opcode latch

always @(posedge bscan_TCK) begin // JTAG spec specifies latch on negative edge in UPDATE_DR state
	if (bscan_RESET)
            opcode <= 4'h0;
	else if (op_reg_en)
            opcode <= opcode_in;
end

//////////////////////////////////////
// Bit counter

always @(posedge bscan_TCK) begin
	if (bscan_RESET)     bit_count <= 6'h0;
        else if (bit_ct_rst) bit_count <= 6'h0;
        else if (bit_ct_en)  bit_count <= bit_count + 6'h1;
end

assign bit_count_max = (bit_count == word_size_bits) ? 1'b1 : 1'b0;
assign bit_count_32 = (bit_count == 6'h20) ? 1'b1 : 1'b0;

////////////////////////////////////////
// Word counter

assign data_to_word_counter = (word_ct_sel) ? decremented_word_count : count_in;
assign decremented_word_count = word_count - 16'h1;

// Technically, since this data (sometimes) comes from the input shift reg, we should latch on
// negedge, per the JTAG spec. But that makes things difficult when incrementing.
always @(posedge bscan_TCK) begin // JTAG spec specifies latch on negative edge in UPDATE_DR state
	if (bscan_RESET)
            word_count <= 16'h0;
        else if (word_ct_en)
            word_count <= data_to_word_counter;
end

assign word_count_zero = (word_count == 16'h0);

////////////////////////////////////////
// tdo mux
// Choose
// 1 : data from internal reg
// 0 : data from biu
////////////////////////////////////////
  
   
assign out_reg_data = (out_reg_data_sel) ? data_from_internal_reg : data_from_fifo;

always @(posedge bscan_TCK) begin
	if (bscan_RESET)           data_out_shift_reg <= 'h0;
	else if (out_reg_ld_en)    data_out_shift_reg <= out_reg_data;
	else if (out_reg_shift_en) data_out_shift_reg <= {1'b0, data_out_shift_reg[REG_WIDTH-1:1]};
end

always @(*) begin
	case (tdo_output_sel) 
            2'h1:    dbg_module_tdo_o = data_out_shift_reg[0];
            2'h2:    dbg_module_tdo_o = crc_match;
            2'h3:    dbg_module_tdo_o = crc_serial_out;
            default: dbg_module_tdo_o = biu_ready;
	endcase
end

/////////////////////////////////////
// CRC module
/////////////////////////////////////
assign crc_data_in = (crc_in_sel) ? bscan_TDI : data_out_shift_reg[0];  // MUX, write or read data

`IP_MODULE_NAME(adbg_crc32) u_adbg_crc32 
  (
   .clk        ( bscan_TCK ), 
   .data       ( crc_data_in ),
   .enable     ( crc_en ),
   .shift      ( crc_shift_en ),
   .clr        ( crc_clr ),
   .rstn       ( ~bscan_RESET ),
   .crc_out    ( crc_data_out ),
   .serial_out ( crc_serial_out )
   );

assign crc_match = (dbg_data_register_i[DR_WIDTH-1 -: 32] == crc_data_out) ? 1'b1 : 1'b0;

////////////////////////////////////////
// Control FSM

// Definition of machine state values.
// Don't worry too much about the state encoding, the synthesis tool
// will probably re-encode it anyway.

// sequential part of the FSM
always @(posedge bscan_TCK) begin
	if (bscan_RESET)
            module_state <= STATE_idle;
        else
            module_state <= module_next_state;
end

// Determination of next state; purely combinatorial
always @(*) begin
	case (module_state)
            STATE_idle: begin
                if (module_cmd && dbg_module_select_i && bscan_UPDATE && burst_read) 
                    module_next_state = STATE_Rbegin;
                else if (module_cmd && dbg_module_select_i && bscan_UPDATE && burst_write) 
                    module_next_state = STATE_Wready;
                else
                    module_next_state = STATE_idle;
            end

            STATE_Rbegin: begin
                if (word_count_zero)
                    module_next_state = STATE_idle;  // set up a burst of size 0, illegal.
                else
                    module_next_state = STATE_Rready;
            end

            STATE_Rready: begin
                if (dbg_module_select_i && bscan_CAPTURE)
                    module_next_state = STATE_Rstatus;
                else
                    module_next_state = STATE_Rready;
            end

            STATE_Rstatus: begin
                if (bscan_UPDATE)
                    module_next_state = STATE_idle;
                else if (biu_ready)
                    module_next_state = STATE_Rburst;
                else
                    module_next_state = STATE_Rstatus;
            end

            STATE_Rburst: begin
                if (bscan_UPDATE)
                    module_next_state = STATE_idle;
                else if (bit_count_max && word_count_zero)
                    module_next_state = STATE_Rcrc;
                else
                    module_next_state = STATE_Rburst;
            end

            STATE_Rcrc: begin
                if (bscan_UPDATE)
                    module_next_state = STATE_idle;
                // This doubles as the 'recovery' state, so stay here until update_dr_i.
                else 
                    module_next_state = STATE_Rcrc;
            end

            STATE_Wready: begin
                if (word_count_zero)
                    module_next_state = STATE_idle;
                else if (dbg_module_select_i && bscan_CAPTURE) 
                    module_next_state = STATE_Wwait;
                else
                    module_next_state = STATE_Wready;
            end

            STATE_Wwait: begin
                if (bscan_UPDATE)
                    module_next_state = STATE_idle;  // client terminated early
                else if (dbg_module_select_i && dbg_data_register_i[DR_WIDTH-1])
                  begin
		     if (jtag_chain_wburst_dly == 0)
		       module_next_state = STATE_Wburst; // Got a start bit
	             else
		       module_next_state = STATE_Wwait_dly;
		  end
	       
                else
                    module_next_state = STATE_Wwait;
            end

	  STATE_Wwait_dly: begin
	     if (bscan_UPDATE)
	       module_next_state = STATE_idle;
	     else if (wwait_dly_cnt == (jtag_chain_wburst_dly-1))
	       module_next_state = STATE_Wburst;
	     else
	       module_next_state = STATE_Wwait_dly;
	  end
	  
		      
          STATE_Wburst: begin
                if (bscan_UPDATE)
                    module_next_state = STATE_idle;  // client terminated early
                else if (bit_count_max) begin
                    if(word_count_zero)
                        module_next_state = STATE_Wcrc;
                    else
                        module_next_state = STATE_Wburst;
                end
                else 
                    module_next_state = STATE_Wburst;
            end

            STATE_Wstatus: begin
                if (bscan_UPDATE)
                    module_next_state = STATE_idle;  // client terminated early    
                else if (word_count_zero)
                    module_next_state = STATE_Wcrc;
                // can't wait until bus ready if multiple devices in chain...
                // Would have to read postfix_bits, then send another start bit and push it through
                // prefix_bits...potentially very inefficient.
                else 
                    module_next_state = STATE_Wburst;
            end

            STATE_Wcrc: begin
                if (bscan_UPDATE)  module_next_state = STATE_idle;  // client terminated early
                else if (bit_count_32) module_next_state = STATE_Wmatch;
                else module_next_state = STATE_Wcrc;
            end

            STATE_Wmatch: begin
                if (bscan_UPDATE)  module_next_state = STATE_idle;
               // This doubles as our recovery state, stay here until update_dr_i
                else module_next_state = STATE_Wmatch;
            end

            default: module_next_state = STATE_idle;  // shouldn't actually happen...
        endcase
end

// Outputs of state machine, pure combinatorial
always @(*) begin
        // Default everything to 0, keeps the case statement simple
        addr_sel          = 1'b1;  // Selects data for address_counter. 0 = data_register_i, 1 = incremented address count
        addr_ct_en        = 1'b0;  // Enable signal for address counter register
        op_reg_en         = 1'b0;  // Enable signal for 'operation' register
        bit_ct_en         = 1'b0;  // enable bit counter
        bit_ct_rst        = 1'b0;  // reset (zero) bit count register
        word_ct_sel       = 1'b1;  // Selects data for byte counter.  0 = data_register_i, 1 = decremented byte count
        word_ct_en        = 1'b0;   // Enable byte counter register
        out_reg_ld_en     = 1'b0;  // Enable parallel load of data_out_shift_reg
        out_reg_shift_en  = 1'b0;  // Enable shift of data_out_shift_reg
        tdo_output_sel    = 2'b1;   // 1 = data reg, 0 = biu_ready, 2 = crc_match, 3 = CRC data
        biu_strobe        = 1'b0;
        crc_clr           = 1'b0;
        crc_en            = 1'b0;      // add the input bit to the CRC calculation
        crc_in_sel        = 1'b0;  // 0 = tdo, 1 = tdi
        crc_shift_en      = 1'b0;
        out_reg_data_sel  = 1'b1;  // 0 = BIU data, 1 = internal register data
        regsel_ld_en      = 1'b0;
        intreg_ld_en      = 1'b0;
        //error_reg_en      = 1'b0;
        //biu_clr_err       = 1'b0;  // Set this to reset the BIU, clearing the biu_err bit
        dbg_module_inhibit_o = 1'b0;  // Don't disable the top-level module in the default case
        wwait_dly_cnt_en = 1'b0;
   
        case (module_state)
            STATE_idle: begin
                addr_sel    = 1'b0;
                word_ct_sel = 1'b0;

                // Operations for internal registers - stay in idle state
                if (dbg_module_select_i & bscan_SHIFT)
                    out_reg_shift_en = 1'b1; // For module regs
                if (dbg_module_select_i & bscan_CAPTURE) begin
                    out_reg_data_sel = 1'b1;  // select internal register data
                    out_reg_ld_en = 1'b1;   // For module regs
                end
                if (dbg_module_select_i & module_cmd & bscan_UPDATE) begin
                    if (intreg_instruction) 
                        regsel_ld_en = 1'b1;  // For module regs
                    if (intreg_write)       
                        intreg_ld_en = 1'b1;  // For module regs
                end

                // Burst operations
                if (module_next_state != STATE_idle) begin  // Do the same to receive read or write opcode
                    addr_ct_en = 1'b1;
                    op_reg_en  = 1'b1;
                    bit_ct_rst = 1'b1;
                    word_ct_en = 1'b1;
                    crc_clr    = 1'b1;
                end
            end

            STATE_Rbegin: begin
                if (!word_count_zero) begin  // Start a biu read transaction
                    biu_strobe = 1'b1;
                    addr_sel   = 1'b1;
                    addr_ct_en = 1'b1;
                end
            end

            STATE_Rready:
                ; // Just a wait state // FIXME ??????? 
      
            STATE_Rstatus: begin
                tdo_output_sel  = 2'h0;
                dbg_module_inhibit_o = 1'b1;    // in case of early termination

                if (module_next_state == STATE_Rburst) begin
                    //error_reg_en     = 1'b1;       // Check the wb_error bit
                    out_reg_data_sel = (count_in==16'd1)? 1'b1 : 1'b0;  // select BIU data
                    out_reg_ld_en    = 1'b1;
                    bit_ct_rst       = 1'b1;
                    word_ct_sel      = 1'b1;
                    word_ct_en       = 1'b1;
                    if (!(decremented_word_count == 0) && !word_count_zero) begin  // Start a biu read transaction
                        biu_strobe    = 1'b1;
                        addr_sel      = 1'b1;
                        addr_ct_en    = 1'b1;
                    end
                end
            end

            STATE_Rburst: begin
                tdo_output_sel     = 2'h1;
                out_reg_shift_en   = 1'b1;
                bit_ct_en          = 1'b1;
                crc_en             = 1'b1;
                crc_in_sel         = 1'b0;  // read data in output shift register LSB (tdo)
                dbg_module_inhibit_o = 1'b1;  // in case of early termination

                if (bit_count_max) begin
                    //error_reg_en     = 1'b1;       // Check the wb_error bit
                    out_reg_data_sel = 1'b0;  // select BIU data
                    out_reg_ld_en    = 1'b1;
                    bit_ct_rst       = 1'b1;
                    word_ct_sel      = 1'b1;
                    word_ct_en       = 1'b1;
                    if (!(decremented_word_count == 0) && !word_count_zero) begin // Start a biu read transaction
                        biu_strobe     = 1'b1;
                        addr_sel       = 1'b1;
                        addr_ct_en     = 1'b1;
                    end
                end
            end

            STATE_Rcrc: begin
                // Just shift out the data, don't bother counting, we don't move on until update_dr_i
                tdo_output_sel = 2'h3;
                crc_shift_en   = 1'b1;
                dbg_module_inhibit_o = 1'b1;
            end

            STATE_Wready:
                ; // Just a wait state

            STATE_Wwait: begin
                tdo_output_sel = 2'h1;
                dbg_module_inhibit_o = 1'b1;    // in case of early termination
                if (module_next_state == STATE_Wburst) begin
                    //biu_clr_err    = 1'b1;  // If error occurred on last transaction of last burst, biu_err is still set.  Clear it.
                    bit_ct_en      = 1'b1;
                    word_ct_sel    = 1'b1;  // Pre-decrement the byte count
                    word_ct_en     = 1'b1;
                    crc_en         = 1'b1;  // CRC gets tdi_i, which is 1 cycle ahead of data_register_i, so we need the bit there now in the CRC
                    crc_in_sel     = 1'b1;  // read data from tdi_i
                end
            end // case: STATE_Wwait

	  STATE_Wwait_dly : begin
	     tdo_output_sel = 2'h1;
             dbg_module_inhibit_o = 1'b1;    // in case of early termination
	     wwait_dly_cnt_en = 1'b1;
             if (module_next_state == STATE_Wburst) begin
                //biu_clr_err    = 1'b1;  // If error occurred on last transaction of last burst, biu_err is still set.  Clear it.
                bit_ct_en      = 1'b1;
                word_ct_sel    = 1'b1;  // Pre-decrement the byte count
                word_ct_en     = 1'b1;
                crc_en         = 1'b1;  // CRC gets tdi_i, which is 1 cycle ahead of data_register_i, so we need the bit there now in the CRC
                crc_in_sel     = 1'b1;  // read data from tdi_i
             end
	  end
	  

            STATE_Wburst: begin
                bit_ct_en       = 1'b1;
                tdo_output_sel  = 2'h1;
                crc_en          = 1'b1;
                crc_in_sel      = 1'b1;  // read data from tdi_i
                dbg_module_inhibit_o = 1'b1;    // in case of early termination

                // It would be better to do this in STATE_Wstatus, but we don't use that state 
                // if ADBG_USE_HISPEED is defined.  
                if(bit_count_max) begin
                    //error_reg_en = 1'b1;       // Check the wb_error bit
                    bit_ct_rst   = 1'b1;  // Zero the bit count
                    // start transaction. Can't do this here if not hispeed, biu_ready
                    // is the status bit, and it's 0 if we start a transaction here.
                    biu_strobe   = 1'b1;  // Start a BIU transaction
                    addr_ct_en   = 1'b1;  // Increment thte address counter
                    // Also can't dec the byte count yet unless hispeed,
                    // that would skip the last word.
                    word_ct_sel  = 1'b1;  // Decrement the byte count
                    word_ct_en   = 1'b1;
                end
            end

            STATE_Wstatus: begin
                tdo_output_sel = 2'h0;  // Send the status bit to TDO
                //error_reg_en = 1'b1;       // Check the wb_error bit
                // start transaction
                biu_strobe = 1'b1;  // Start a BIU transaction
                word_ct_sel = 1'b1;  // Decrement the byte count
                word_ct_en = 1'b1;
                bit_ct_rst = 1'b1;  // Zero the bit count
                addr_ct_en = 1'b1;  // Increment thte address counter
                dbg_module_inhibit_o = 1'b1;    // in case of early termination
            end

            STATE_Wcrc: begin
                bit_ct_en = 1'b1;
                dbg_module_inhibit_o = 1'b1;    // in case of early termination
                if (module_next_state == STATE_Wmatch)
                    tdo_output_sel = 2'h2;  // This is when the 'match' bit is actually read
            end

            STATE_Wmatch: begin
                tdo_output_sel = 2'h2;
                dbg_module_inhibit_o = 1'b1;
                // Bit of a hack here...an error on the final write won't be detected in STATE_Wstatus like the rest, 
                // so we assume the bus transaction is done and check it / latch it into the error register here.
                //if (module_next_state == STATE_idle)
                //    error_reg_en = 1'b1;
            end

            default: ;
        endcase
end


   assign biu_ready = 1'b1;

   
   

   always @(posedge bscan_TCK)
      if (bscan_RESET)
	wwait_dly_cnt <= 8'h0;
      else if (wwait_dly_cnt_en)
	wwait_dly_cnt <= wwait_dly_cnt + 1;
      else
	wwait_dly_cnt <= 8'h0;
   
   //To handle the JTAG Write Burst Data to SPI FLASH.
   //Store into FIFO.\
   reg burst_data_wr_valid0;
   reg burst_data_wr_valid1;
   
   always @(posedge bscan_TCK) begin
	if (bscan_RESET)
	  begin
	     burst_data_wr_valid0 <= 1'b0;
	   
	  end

	else if (module_state == STATE_Wburst)
	  begin
	     burst_data_wr_valid0 <= word_ct_sel & word_ct_en;
	  end

	else
	  burst_data_wr_valid0 <= 1'b0;
      
      
   end // always @ (posedge bscan_TCK)

     always @(posedge bscan_TCK) begin
	if (bscan_RESET)
	  begin
	     burst_data_wr_valid1 <= 1'b0;
	  end
	
	else
	  begin
	     burst_data_wr_valid1 <= burst_data_wr_valid0;
	  end
	
     end // always @ (posedge bscan_TCK)
   
   assign burst_data_wr_valid = burst_data_wr_valid1;
   
   	//== ASCII state decoding

	/*AUTOASCIIENUM("module_state", "module_state_ascii", "STATE_")*/
	// Beginning of automatic ASCII enum decoding
	reg [55:0]	module_state_ascii;	// Decode of module_state
	always @(module_state) begin
	   case ({module_state})
	     STATE_idle:    module_state_ascii = "idle   ";
	     STATE_Rbegin:  module_state_ascii = "rbegin ";
	     STATE_Rready:  module_state_ascii = "rready ";
	     STATE_Rstatus: module_state_ascii = "rstatus";
	     STATE_Rburst:  module_state_ascii = "rburst ";
	     STATE_Wready:  module_state_ascii = "wready ";
	     STATE_Wwait:   module_state_ascii = "wwait  ";
	     STATE_Wburst:  module_state_ascii = "wburst ";
	     STATE_Wstatus: module_state_ascii = "wstatus";
	     STATE_Rcrc:    module_state_ascii = "rcrc   ";
	     STATE_Wcrc:    module_state_ascii = "wcrc   ";
	     STATE_Wmatch:  module_state_ascii = "wmatch ";
	     STATE_Wwait_dly : module_state_ascii = "wwait_dly";
	     default:       module_state_ascii = "%Error ";
	   endcase
	end
	// End of automatics


//   assign  rfifo_rd_en = (!out_reg_data_sel) ? ( 
//						(burst_read0 & ~burst_read1) || 
//						( burst_read0 & ~word_count_zero & out_reg_ld_en) 
//						) : 1'b0;


   assign  rfifo_rd_en = (burst_read0 & ~burst_read1) ? 1'b1 :
			 (!out_reg_data_sel) ? ( burst_read0 & (word_count>1) & out_reg_ld_en) :
			 1'b0;
   
 
endmodule



/////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2013-2019, Efinix Inc., all rights reserved.
//
// Description:
// This is EFX_SPI_LOADER_TOP to allow customer load the bitstream into SPI
// Flash.
//
//
//
// ------------------------------------------------------------------------------
// REVISION:
//
// 1.0 Release first version of EFX SPI LOADER.
// 1.1 15/8/2019 - Final Release. 
/////////////////////////////////////////////////////////////////////////////////
`resetall
`timescale 1 ps/1 ps

module `IP_MODULE_NAME(efx_spi_loader_top) (
    //System
    input rstn,
    input clkin,
 //   input user_clk,
 //   input user_lock,
 //   output JTAG_lock,
    // SPI flash interface
    input miso,
    input miso_1,
    output sclk,
    output nss,
    output nss_1,
    output mosi,
    output mosi_1,
    
    output wp_n,
    output hold_n,
    output osc_inst1_ENA,
    
    // JTAG interface
    input  jtag_inst1_CAPTURE,
    input  jtag_inst1_DRCK,
    input  jtag_inst1_RESET,
    input  jtag_inst1_RUNTEST,
    input  jtag_inst1_SEL,
    input  jtag_inst1_SHIFT,
    input  jtag_inst1_TCK,
    input  jtag_inst1_TDI,
    input  jtag_inst1_TMS,
    input  jtag_inst1_UPDATE,
    output jtag_inst1_TDO
    );
    
    (* async_reg = "true" *) reg [1:0] rstn_sync;

        always @ (posedge clkin or negedge rstn) begin
            if (!rstn)
                rstn_sync <= 2'b00;
            else
                rstn_sync <= {rstn_sync[0],1'b1};
        end
    
   function integer depth2width;
      input [31:0] 	  depth;
      begin
	 if (depth > 1) begin
	    depth = depth - 1;
	    for (depth2width=0; depth>0; depth2width = depth2width + 1)
	      depth = depth>>1;
	 end
	 else
	   depth2width = 0;
      end
   endfunction
    
    parameter FPGA_ID = 8'd1;
    parameter WFIFO_DEPTH_256 = 8'd60;
    parameter RFIFO_DEPTH_256 = 8'd60;
    parameter ENABLE_DUAL_FLASH = 0;

   //FIFO Parameters
   parameter WFIFO_DEPTH = WFIFO_DEPTH_256 * 256;
   parameter RFIFO_DEPTH = RFIFO_DEPTH_256 * 256;
   parameter SPI_ADDR_WIDTH = (WFIFO_DEPTH>RFIFO_DEPTH) ?
			      depth2width(WFIFO_DEPTH) :
			      depth2width(RFIFO_DEPTH);
			      
   localparam CS_WIDTH = 15;
   localparam DR_WIDTH = 82;
   
   //Signals
   wire [DR_WIDTH-1:0] dbg_data_register_w;
   wire [(CS_WIDTH-1):0] 	dbg_module_inhibit_w;
   wire [(CS_WIDTH-1):0] 	dbg_module_tdo_w;
   wire [CS_WIDTH-1:0] 	dbg_module_select_w;
   wire 		  wfifo_empty;
   wire 		  rfifo_full;

   //SPI Interfacing 
   wire 		  pll_locked;
   wire 		  busy;
   wire 		  data_valid;
   wire 		  spi_cmd_en;
   wire           spi_flash_select;
   wire           spi_flash_dual_mode;
   wire [4:0] 		  spi_cmd;
   wire [31:0] 		  spi_addr;
   wire [7:0] 		  spi_wr_data;
   wire [15:0]         status_reg_16B;
   wire [7:0] 		  spi_cmd_instr;
   wire [7:0] 		  spi_rd_data;
   wire [23:0] 		  jedec_id_reg;
   wire [7:0] 		  manufacturing_id_reg;
   wire [63:0] 		  unique_id_reg;
   wire [7:0] 		  device_id_reg;
   wire [7:0] 		  spi_flash_rd_status_reg0 ;
   wire [7:0] 		  spi_flash_rd_status_reg1 ;
   wire [7:0] 		  spi_flash_rd_status_reg2 ;
   wire [15:0] 		  spi_flash_rd_nonvolatile_config;
   wire 		  erase_en;
   wire [4:0] 		  fsm_status;
   wire [7:0] 		  burst_data_wr;
   wire 		  burst_data_wr_valid;
   wire [7:0] 		  wfifo_data, wfifo_data_1;
   wire 		  wfifo_rd;
    wire 		  burst_data_rd_valid;
   wire [7:0] 		  burst_data_rd;
   wire 		  rfifo_rd;
   wire 		  rfifo_empty;
   wire [7:0] 		  rfifo_data;
   wire [7:0] 		  w_burst_size;
   wire [7:0] 		  r_burst_size;
   wire [15:0] 		  wr_nonvolatile_config;
   wire 		  page_program_done;
   wire 		  JTAG_lock, JTAG_locked;
   wire           jtag_clk;
   
   assign JTAG_locked = 1'b1;
   //Ti60F100 SPI flash specific use case
   assign wp_n = 1'b1;
   assign hold_n = 1'b1;   
   assign osc_inst1_ENA = 1'b1;  //this pin is to drive the internal osc enable pin
/////////////////////////////////////////////////////////////////
//EFX_DEBUG_HUB
//This block handles the jtag serial data to parallel data.
/////////////////////////////////////////////////////////////////
`ifndef SIM
EFX_GBUFCE #(.CE_POLARITY(1'b1)) CLKBUF_JTAG_TCK (.CE(1'b1), .I(jtag_inst1_TCK), .O(bscan_TCK_buffered ));
assign jtag_clk = bscan_TCK_buffered;
`else
assign jtag_clk = jtag_inst1_TCK;
`endif

   `IP_MODULE_NAME(efx_dbg_hub) #(
    .DR_WIDTH    (DR_WIDTH)
   ) u_efx_dbg_hub
     (
      // Outputs
      .bscan_TDO			(jtag_inst1_TDO),
      .dbg_module_selects_o		(dbg_module_select_w),
      .dbg_data_register_o		(dbg_data_register_w),
      // Inputs
      .bscan_CAPTURE			(jtag_inst1_CAPTURE),
      .bscan_DRCK			(jtag_inst1_DRCK),
      .bscan_RESET			(jtag_inst1_RESET),
      .bscan_RUNTEST			(jtag_inst1_RUNTEST),
      .bscan_SEL			(jtag_inst1_SEL),
      .bscan_SHIFT			(jtag_inst1_SHIFT),
      .bscan_TCK			(jtag_clk),
      .bscan_TDI			(jtag_inst1_TDI),
      .bscan_TMS			(jtag_inst1_TMS),
      .bscan_UPDATE			(jtag_inst1_UPDATE),
      .dbg_module_inhibit_i		(dbg_module_inhibit_w),
      .dbg_module_tdo_i			(dbg_module_tdo_w));

///////////////////////////////////////////////////////////////////
//EFX_PGM_SPI Block
//This block decode the commands from JTAG.
//Handles the burst write and burst read command as well. 
///////////////////////////////////////////////////////////////////
   assign dbg_module_inhibit_w[14:1] = 14'b0;
   assign dbg_module_tdo_w[14:1]     = 14'b0;
  // assign dbg_module_select_w[14:1] = 14'b0;
   
   `IP_MODULE_NAME(efx_pgm_spi) #(
    .WFIFO_DEPTH_256  (WFIFO_DEPTH_256),
    .RFIFO_DEPTH_256  (RFIFO_DEPTH_256),    
    .DR_WIDTH    (DR_WIDTH),
    .FPGA_ID    (FPGA_ID)
   ) u_efx_pgm_spi
     (
      //Burst Data Interfacing to SPI SHIFTER BLOCK. 
      .burst_data_wr                   (burst_data_wr),           //8-bits burst data.
      .burst_data_wr_valid             (burst_data_wr_valid),     //Write Burst Data valid flag. 
      .rfifo_rd_en                     (rfifo_rd),
      .data_from_fifo                  (rfifo_data),
      .w_burst_size                    (w_burst_size),            //Burst Write Data Size in `IP_MODULE_NAME(efx_spi_shifter). 
      .r_burst_size                    (r_burst_size),            //Burst Read Data Size in efx_sphi_shifter.
      .wr_nonvolatile_config           (wr_nonvolatile_config),   //Write Non-Volatile Configuration Register. 
      //To SPI Flash.
      .spi_cmd_out                      (spi_cmd[4:0]),
      .spi_cmd_en_out                   (spi_cmd_en),
      .spi_flash_select                 (spi_flash_select),
      .spi_flash_dual_mode              (spi_flash_dual_mode),
      .spi_flash_addr_out               (spi_addr[31:0]),
      .spi_wdata                        (spi_wr_data[7:0]),
      .status_reg_16B                   (status_reg_16B), 
      .spi_cmd_instr                    (spi_cmd_instr[7:0]),
      // Outputs
      .JTAG_lock			(JTAG_lock),
      .dbg_module_inhibit_o		(dbg_module_inhibit_w[0]),
      .dbg_module_tdo_o			(dbg_module_tdo_w[0]),
      // Inputs
      .clkin				(clkin),
      .JTAG_locked			(JTAG_locked),
      .bscan_CAPTURE			(jtag_inst1_CAPTURE),
      .bscan_DRCK			(jtag_inst1_DRCK),
      .bscan_RESET			(jtag_inst1_RESET),
      .bscan_RUNTEST			(jtag_inst1_RUNTEST),
      .bscan_SEL			(jtag_inst1_SEL),
      .bscan_SHIFT			(jtag_inst1_SHIFT),
      .bscan_TCK			(jtag_clk),
      .bscan_TDI			(jtag_inst1_TDI),
      .bscan_TMS			(jtag_inst1_TMS),
      .bscan_UPDATE			(jtag_inst1_UPDATE),
      .dbg_module_select_i		(dbg_module_select_w[0]),
      .dbg_data_register_i		(dbg_data_register_w[DR_WIDTH-1:0]),
      .wfifo_empty          (wfifo_empty),
      .rfifo_full			(rfifo_full),
      .rfifo_empty                      (rfifo_empty), 
      .jedec_id_reg                     (jedec_id_reg),
      .manufacturing_id_reg             (manufacturing_id_reg),
      .unique_id_reg                    (unique_id_reg[63:0]),
      .device_id_reg                    (device_id_reg[7:0]),
      .spi_flash_rd_status_reg0         (spi_flash_rd_status_reg0),
      .spi_flash_rd_status_reg1         (spi_flash_rd_status_reg1),
      .spi_flash_rd_status_reg2         (spi_flash_rd_status_reg2),
      .spi_flash_rd_nonvolatile_config  (spi_flash_rd_nonvolatile_config),
      .erase_en                         (erase_en),
      .fsm_status                       (fsm_status),
      .page_program_done                (page_program_done)
      );
   


////////////////////////////////////////////////
//SPI Master - Interface to SPI Flash
////////////////////////////////////////////////

  

   assign pll_locked = 1'b1;
      
generate if (ENABLE_DUAL_FLASH) begin : DUAL_FLASH
wire [7:0] burst_data_rd_0, burst_data_rd_1;
wire burst_data_rd_valid_0, burst_data_rd_valid_1;
wire wfifo_rd_0, wfifo_rd_1;
wire page_program_done_0, page_program_done_1;
wire [23:0] jedec_id_reg_0, jedec_id_reg_1;
wire [7:0] manufacturing_id_reg_0, manufacturing_id_reg_1;
wire [63:0] unique_id_reg_0, unique_id_reg_1;
wire [7:0] device_id_reg_0, device_id_reg_1;
wire [7:0] spi_flash_rd_status_reg0_0, spi_flash_rd_status_reg0_1;
wire [7:0] spi_flash_rd_status_reg1_0, spi_flash_rd_status_reg1_1;
wire [7:0] spi_flash_rd_status_reg2_0, spi_flash_rd_status_reg2_1;
wire [15:0] spi_flash_rd_nonvolatile_config_0, spi_flash_rd_nonvolatile_config_1;
wire erase_en_0, erase_en_1, spi_cmd_en_0, spi_cmd_en_1;
wire [4:0] fsm_status_0, fsm_status_1;
wire busy_0, busy_1, nss_int_0, nss_int_1;
wire wfifo_empty_0, wfifo_empty_1;

   wire [7:0]       wfifo_data_2, wfifo_data_1_mux, wfifo_data_0_mux;
   wire             wfifo_rd_2;
   wire             wfifo_empty_2, wfifo_empty_1_mux, wfifo_empty_0_mux;

assign wfifo_empty = spi_flash_dual_mode ?  wfifo_empty_1_mux && wfifo_empty_0_mux  : wfifo_empty_2;
assign busy = spi_flash_select ? busy_1 : busy_0;
assign burst_data_rd = spi_flash_select ? burst_data_rd_1 : burst_data_rd_0;
assign burst_data_rd_valid = spi_flash_select ? burst_data_rd_valid_1 : burst_data_rd_valid_0;
assign page_program_done = spi_flash_select ? page_program_done_1 : page_program_done_0;
assign jedec_id_reg = spi_flash_select ? jedec_id_reg_1 : jedec_id_reg_0;
assign manufacturing_id_reg = spi_flash_select ? manufacturing_id_reg_1 : manufacturing_id_reg_0;
assign unique_id_reg = spi_flash_select ? unique_id_reg_1 : unique_id_reg_0;
assign device_id_reg = spi_flash_select ? device_id_reg_1 : device_id_reg_0;
assign spi_flash_rd_status_reg0 = spi_flash_select ? spi_flash_rd_status_reg0_1 : spi_flash_rd_status_reg0_0;
assign spi_flash_rd_status_reg1 = spi_flash_select ? spi_flash_rd_status_reg1_1 : spi_flash_rd_status_reg1_0;
assign spi_flash_rd_status_reg2 = spi_flash_select ? spi_flash_rd_status_reg2_1 : spi_flash_rd_status_reg2_0;
assign spi_flash_rd_nonvolatile_config = spi_flash_select ? spi_flash_rd_nonvolatile_config_1 : spi_flash_rd_nonvolatile_config_0;
assign erase_en = spi_flash_select ? erase_en_1 : erase_en_0;
assign fsm_status = spi_flash_select ? fsm_status_1 : fsm_status_0;
assign nss = spi_flash_select ? 1'b1 : nss_int_0;
assign nss_1 = spi_flash_select ? nss_int_1 : 1'b1;
assign spi_cmd_en_0 = spi_flash_select ? 1'b0 : spi_cmd_en;
assign spi_cmd_en_1 = spi_flash_select ? spi_cmd_en : 1'b0;

assign wfifo_rd_2 = spi_flash_select ? wfifo_rd_1 : wfifo_rd_0;

assign wfifo_data_0_mux  = spi_flash_dual_mode ? wfifo_data  : wfifo_data_2;
assign wfifo_data_1_mux  = spi_flash_dual_mode ? wfifo_data_1  : wfifo_data_2;
assign wfifo_empty_0_mux = spi_flash_dual_mode ? wfifo_empty_0 : wfifo_empty_2;
assign wfifo_empty_1_mux = spi_flash_dual_mode ? wfifo_empty_1 : wfifo_empty_2;

   `IP_MODULE_NAME(efx_spi_shifter) #(
    .RFIFO_DEPTH_256    (RFIFO_DEPTH_256),
    .WFIFO_DEPTH_256    (WFIFO_DEPTH_256)
   ) u_efx_spi_shifter_0
     (
      //Outputs
      .jedec_id_reg                     (jedec_id_reg_0),
      .manufacturing_id_reg             (manufacturing_id_reg_0),
      .unique_id_reg                    (unique_id_reg_0),
      .device_id_reg                    (device_id_reg_0),
      .spi_flash_rd_status_reg0         (spi_flash_rd_status_reg0_0),
      .spi_flash_rd_status_reg1         (spi_flash_rd_status_reg1_0),
      .spi_flash_rd_status_reg2         (spi_flash_rd_status_reg2_0),
      .spi_flash_rd_nonvolatile_config  (spi_flash_rd_nonvolatile_config_0), 
      .erase_en                         (erase_en_0),
      .fsm_status                       (fsm_status_0), 
    
      // Outputs
      .data_out				(burst_data_rd_0),        //Burst Read Data to FIFO
      .busy				    (busy_0),
      .data_valid			(burst_data_rd_valid_0),  //Burst Read Data Valid Flag. 
      .sclk				    (sclk),            //spi flash SCLK (Port)  
      .nss				    (nss_int_0),             //spi active low chip select (Port) 
      .mosi				    (mosi),            //spi MOSI (Port)
      .wfifo_rd             (wfifo_rd_0),        //write fifo (read). 
      .page_program_done    (page_program_done_0), // write done flag. 
      // Inputs
      .nrst                 (rstn_sync[1]),            //active low system reset. 
      .clkin                (clkin),           //50MHz clock . 
      .locked               (pll_locked),      //PLL Locked
      .spi_cmd_en           (spi_cmd_en_0),         //From efx spi pgm
      .spi_cmd              (spi_cmd[4:0]),       //From efx spi pgm
      .address              (spi_addr[31:0]),     //From efx spi pgm
      .data_in              (spi_wr_data[7:0]),   //From efx spi pgm
      .status_reg_16B       (status_reg_16B),   //From efx spi pgm
      .spi_cmd_instr        (spi_cmd_instr[7:0]), //From efx spi pgm
      .burst_data_wr        (wfifo_data_0_mux),
      .miso                 (miso),           //spi flash MISO (Port) 
      .w_burst_size         (w_burst_size),   //spi burst write data size. 
      .r_burst_size         (r_burst_size),   //spi burst read data size.
      .wr_nonvolatile_config(wr_nonvolatile_config)  
      );
      
   `IP_MODULE_NAME(efx_spi_shifter) #(
    .RFIFO_DEPTH_256    (RFIFO_DEPTH_256),
    .WFIFO_DEPTH_256    (WFIFO_DEPTH_256)
   ) u_efx_spi_shifter_1
     (
      //Outputs
      .jedec_id_reg                     (jedec_id_reg_1),
      .manufacturing_id_reg             (manufacturing_id_reg_1),
      .unique_id_reg                    (unique_id_reg_1),
      .device_id_reg                    (device_id_reg_1),
      .spi_flash_rd_status_reg0         (spi_flash_rd_status_reg0_1),
      .spi_flash_rd_status_reg1         (spi_flash_rd_status_reg1_1),
      .spi_flash_rd_status_reg2         (spi_flash_rd_status_reg2_1),
      .spi_flash_rd_nonvolatile_config  (spi_flash_rd_nonvolatile_config_1), 
      .erase_en                         (erase_en_1),
      .fsm_status                       (fsm_status_1), 
    
      // Outputs
      .data_out				(burst_data_rd_1),        //Burst Read Data to FIFO
      .busy				    (busy_1),
      .data_valid			(burst_data_rd_valid_1),  //Burst Read Data Valid Flag. 
      .sclk				    (),             //not used
      .nss				    (nss_int_1),             //spi active low chip select (Port) 
      .mosi				    (mosi_1),            //spi MOSI (Port)
      .wfifo_rd             (wfifo_rd_1),        //write fifo (read). 
      .page_program_done    (page_program_done_1), // write done flag. 
      // Inputs
      .nrst                 (rstn_sync[1]),            //active low system reset. 
      .clkin                (clkin),           //50MHz clock . 
      .locked               (pll_locked),      //PLL Locked
      .spi_cmd_en           (spi_cmd_en_1),         //From efx spi pgm
      .spi_cmd              (spi_cmd[4:0]),       //From efx spi pgm
      .address              (spi_addr[31:0]),     //From efx spi pgm
      .data_in              (spi_wr_data[7:0]),   //From efx spi pgm
      .status_reg_16B       (status_reg_16B),   //From efx spi pgm
      .spi_cmd_instr        (spi_cmd_instr[7:0]), //From efx spi pgm
      .burst_data_wr        (wfifo_data_1_mux),
      .miso                 (miso_1),           //spi flash MISO (Port) 
      .w_burst_size         (w_burst_size),   //spi burst write data size. 
      .r_burst_size         (r_burst_size),   //spi burst read data size.
      .wr_nonvolatile_config(wr_nonvolatile_config)  
      );

   /////////////////////////////////////////
   //Buffer : From JTAG `IP_MODULE_NAME(efx_pgm_spi) to spi shifter.
   /////////////////////////////////////////
   
    `IP_MODULE_NAME(asymwidth_dcfifo) #(
       .WDATA_WIDTH(4),                   //write Data Width - 4 bits.  
       .WFIFO_DEPTH(WFIFO_DEPTH),
       .RDATA_WIDTH(8),                    
       .RFIFO_DEPTH(WFIFO_DEPTH/2)
    ) dual_port_dcfifo_0 (
      .i_arst    (~rstn_sync[1] || ~spi_flash_dual_mode),
      .i_wclk    (jtag_clk),
      .i_we      (burst_data_wr_valid),
      .i_wdata   (burst_data_wr[3:0]),
      .i_rclk    (clkin),          
      .i_re      (wfifo_rd_0),           //TBD - Connect to SPI Shifter. 
      .o_full    (),              
      .o_empty   (wfifo_empty_0),        //Indicate that the FIFO is empty, ready for software to do burst write. 
      .o_rdata   (wfifo_data[7:0])
    );
    
    `IP_MODULE_NAME(asymwidth_dcfifo) #(
       .WDATA_WIDTH(4),                   //write Data Width - 4 bits.  
       .WFIFO_DEPTH(WFIFO_DEPTH),
       .RDATA_WIDTH(8),                    
       .RFIFO_DEPTH(WFIFO_DEPTH/2)
    ) dual_port_dcfifo_1 (
      .i_arst    (~rstn_sync[1] || ~spi_flash_dual_mode ),
      .i_wclk    (jtag_clk),
      .i_we      (burst_data_wr_valid),
      .i_wdata   (burst_data_wr[7:4]),
      .i_rclk    (clkin),          
      .i_re      (wfifo_rd_1),           //TBD - Connect to SPI Shifter. 
      .o_full    (),              
      .o_empty   (wfifo_empty_1),        //Indicate that the FIFO is empty, ready for software to do burst write. 
      .o_rdata   (wfifo_data_1[7:0])
    );

   // Use for case like access to UPPER flash or LOWER flash only
   // IF spi_flash_dual_mode = 1, put this fifo under reset 
   `IP_MODULE_NAME(dual_clock_fifo_wrapper) #(
      .DATA_WIDTH(8),                   //Data Width - 8 bits.
      .ADDR_WIDTH(SPI_ADDR_WIDTH),      //Address - 24 bits.
      .LATENCY(1),                      //Flag latency - 1 
      .FIFO_MODE("STD_FIFO"),           //Standard FIFO
      .RAM_INIT_FILE(""),               //No Intialization file for ram.
      .COMPATIBILITY("E"),              //
      .OUTPUT_REG("FALSE"),             //No output register. 
      .CHECK_FULL("TRUE"),              //Skip the write if fifo full.
      .CHECK_EMPTY("TRUE"),             //Skip the read if fifo empty. 
      .AFULL_THRESHOLD(WFIFO_DEPTH-1),
      .AEMPTY_THRESHOLD(1)
   ) dual_port_dcfifo_2 (
      .i_arst    (~rstn_sync[1] || spi_flash_dual_mode),
      .i_wclk    (jtag_clk),
      .i_we      (burst_data_wr_valid),
      .i_wdata   (burst_data_wr),
      .i_rclk    (clkin),
      .i_re      (wfifo_rd_2),
      .o_full    (),
      .o_empty   (wfifo_empty_2),       //Indicate that the FIFO is empty, ready for software to do burst write. 
      .o_rdata   (wfifo_data_2),
      .o_afull   (),
      .o_wcnt    (),
      .o_aempty  (),
      .o_rcnt    ()
   );

end
else begin
   `IP_MODULE_NAME(efx_spi_shifter) #(
    .RFIFO_DEPTH_256    (RFIFO_DEPTH_256),
    .WFIFO_DEPTH_256    (WFIFO_DEPTH_256)
   ) u_efx_spi_shifter
     (
      //Outputs
      .jedec_id_reg                     (jedec_id_reg),
      .manufacturing_id_reg             (manufacturing_id_reg[7:0]),
      .unique_id_reg                    (unique_id_reg[63:0]),
      .device_id_reg                    (device_id_reg[7:0]),
      .spi_flash_rd_status_reg0         (spi_flash_rd_status_reg0),
      .spi_flash_rd_status_reg1         (spi_flash_rd_status_reg1),
      .spi_flash_rd_status_reg2         (spi_flash_rd_status_reg2),
      .spi_flash_rd_nonvolatile_config  (spi_flash_rd_nonvolatile_config), 
      .erase_en                         (erase_en),
      .fsm_status                       (fsm_status), 
    
      // Outputs
      .data_out				(burst_data_rd),        //Burst Read Data to FIFO
      .busy				    (busy),
      .data_valid			(burst_data_rd_valid),  //Burst Read Data Valid Flag. 
      .sclk				    (sclk),            //spi flash SCLK (Port)  
      .nss				    (nss),             //spi active low chip select (Port) 
      .mosi				    (mosi),            //spi MOSI (Port)
      .wfifo_rd             (wfifo_rd),        //write fifo (read). 
      .page_program_done    (page_program_done), // write done flag. 
      // Inputs
      .nrst                 (rstn_sync[1]),            //active low system reset. 
      .clkin                (clkin),           //50MHz clock . 
      .locked               (pll_locked),      //PLL Locked
      .spi_cmd_en           (spi_cmd_en),         //From efx spi pgm
      .spi_cmd              (spi_cmd[4:0]),       //From efx spi pgm
      .address              (spi_addr[31:0]),     //From efx spi pgm
      .data_in              (spi_wr_data[7:0]),   //From efx spi pgm
      .status_reg_16B       (status_reg_16B),   //From efx spi pgm
      .spi_cmd_instr        (spi_cmd_instr[7:0]), //From efx spi pgm
      .burst_data_wr        (wfifo_data),
      .miso                 (miso),           //spi flash MISO (Port) 
      .w_burst_size         (w_burst_size),   //spi burst write data size. 
      .r_burst_size         (r_burst_size),   //spi burst read data size.
      .wr_nonvolatile_config(wr_nonvolatile_config)  
      );

   /////////////////////////////////////////
   //Buffer : From JTAG `IP_MODULE_NAME(efx_pgm_spi) to spi shifter.
   /////////////////////////////////////////
   
   `IP_MODULE_NAME(dual_clock_fifo_wrapper)
     #(
       .DATA_WIDTH(8),                   //Data Width - 8 bits.      
       .ADDR_WIDTH(SPI_ADDR_WIDTH),      //Address - 24 bits.
       .LATENCY(1),                      //Flag latency - 1 
       .FIFO_MODE("STD_FIFO"),           //Standard FIFO
       .RAM_INIT_FILE(""),               //No Intialization file for ram.
       .COMPATIBILITY("E"),              //
       .OUTPUT_REG("FALSE"),             //No output register. 
       .CHECK_FULL("TRUE"),              //Skip the write if fifo full.             
       .CHECK_EMPTY("TRUE"),             //Skip the read if fifo empty. 
       .AFULL_THRESHOLD(WFIFO_DEPTH-1),
       .AEMPTY_THRESHOLD(1)
       )
   u_wfifo
     (
      .i_arst    (~rstn_sync[1]),
      .i_wclk    (jtag_clk),
      .i_we      (burst_data_wr_valid),
      .i_wdata   (burst_data_wr),
      .i_rclk    (clkin),          
      .i_re      (wfifo_rd),           //TBD - Connect to SPI Shifter. 
      .o_full    (),              
      .o_empty   (wfifo_empty),        //Indicate that the FIFO is empty, ready for software to do burst write. 
      .o_rdata   (wfifo_data),
      .o_afull   (),
      .o_wcnt    (),
      .o_aempty  (),
      .o_rcnt    ()
      );
end
endgenerate 

////////////////////////////////////////////////
//FIFO
//Burst Write Data
//#1 Write bitstream into FIFO first.
//#2 Kick off the burst write in SPI Shifter.
//Burst Read Data.
//#1 Burst read the data and store into FIFO.
//#2 Kick off the burst read data.   
////////////////////////////////////////////////

   ////////////////////////////////////////////////////////////
   //Buffer : From SPI SHIFTER TO EFX_PGM_SPI
   ////////////////////////////////////////////////////////////

//   assign rfifo_data = burst_data_rd;
   
  
   `IP_MODULE_NAME(dual_clock_fifo_wrapper)
     #(
       .DATA_WIDTH(8),                   //Data Width - 8 bits.      
       .ADDR_WIDTH(SPI_ADDR_WIDTH),      //Address - 24 bits.
       .LATENCY(1),                      //Flag latency - 1 
       .FIFO_MODE("STD_FIFO"),           //Standard FIFO
       .RAM_INIT_FILE(""),               //No Intialization file for ram.
       .COMPATIBILITY("E"),              //
       .OUTPUT_REG("FALSE"),             //No output register. 
       .CHECK_FULL("TRUE"),              //Skip the write if fifo full.             
       .CHECK_EMPTY("TRUE"),             //Skip the read if fifo empty. 
       .AFULL_THRESHOLD(RFIFO_DEPTH-1),
       .AEMPTY_THRESHOLD(1)
       )
   u_rfifo
     (
      .i_arst    (~rstn_sync[1]),
      .i_wclk    (clkin),
      .i_we      (burst_data_rd_valid),
      .i_wdata   (burst_data_rd),
      .i_rclk    (jtag_clk),          
      .i_re      (rfifo_rd),           //TBD - Connect to SPI Shifter. 
      .o_full    (),              
      .o_empty   (rfifo_empty),        //Indicate that the FIFO is empty, ready for software to do burst write. 
      .o_rdata   (rfifo_data),
      .o_afull   (rfifo_full),         //Indicate that the FIFO is full. 
      .o_wcnt    (),
      .o_aempty  (),
      .o_rcnt    ()
      );
  
   
   
   
  

   
endmodule // efx_spi_loader_top




/////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2013-2019, Efinix Inc., all rights reserved.
//
// Description:
// This is EFX_SPI_LOADER_TOP to allow customer load the bitstream into SPI
// Flash.
//
//
//
// ------------------------------------------------------------------------------
// REVISION:
// 1.0 : Initial Release
/////////////////////////////////////////////////////////////////////////////////
`resetall
`timescale 1 ps/1 ps
//`include "dbg_defines.v"

  module `IP_MODULE_NAME(efx_spi_shifter)
    #(
      parameter RFIFO_DEPTH_256 = 8'd60,
      parameter WFIFO_DEPTH_256 = 8'd60
      )
   (
    input nrst,
    input clkin,
    
    // to PLL
    input locked,
    
    // command interface - spi_cmd
    //1 soft_reset,         // soft reset. 
    //2 read,               // read 
    //3 read_device_id,     // read device id
    //4 read_unique_id,     // read unique id
    //5 read_reg,	    // read status register 1/2/3; data_in as command
    //6 read_jedec_id,      // read jedec id.
    //8 write_enable,	    // write enable (0x06)
    //9 write_reg1,	    // write status register 1
    //10 write_reg2,	    // write status register 2
    //11 write_reg3,	    // write status register 3 
    //12 write,             // Page Program 
    //13 erase,             // Ease
    //14 read_reg1          // read status register 1
    //15 read_reg2          // read status register 2
    //16 read_reg3          // read status register 3
    //17 read_manufacturing_id // read manufacturing id.
    //18 write_enable_for_volatile,	    // write volatile status (0x50)
    //19 write_disable                      // write disable (0x04)
    //20 fast_read           //Fast Read
    //21 write_non_volatile_configuration
    //22 read_non_volatile_configuration
    input spi_cmd_en,       //To enable the spi_cmd opcode command. 
    input [4:0] spi_cmd,
    input [7:0] spi_cmd_instr, 
    input [31:0] address,
    input [7:0] data_in,	// command or data to input
    input [15:0] status_reg_16B, // for 16-bit status register data
    input [7:0] burst_data_wr,
    input [7:0] w_burst_size,   //SPI Burst Write Size. 1 - 256, 2 - 512
    input [7:0] r_burst_size,   //SPI Burst Read Size.  1 - 256, 2 - 512
    input [15:0]      wr_nonvolatile_config,
    
      
    output [7:0] data_out,
    output busy,
    output data_valid,

    //Output
    output reg [23:0] jedec_id_reg,
    output reg [7:0] manufacturing_id_reg,
    output reg [63:0] unique_id_reg,
    output reg [7:0] device_id_reg,
    output reg [7:0] spi_flash_rd_status_reg0 ,
    output reg [7:0] spi_flash_rd_status_reg1 ,
    output reg [7:0] spi_flash_rd_status_reg2 ,
    output reg [15:0] spi_flash_rd_nonvolatile_config,
    output reg erase_en,      //This bit indicate erase command is enabled. When user issue write enable command, this bit set to high.
                              //When user isse write disable command, this bit set to low.
    output [4:0]  fsm_status,
    output wire wfifo_rd,
    output reg page_program_done,
    // SPI interface
    input miso,		// SPI MISO
    output sclk,		// SPI SCLK
    output nss,		// SPI SS
    output mosi		// SPI MOSI
    );
   
localparam SCLK_FREQ = 6'd5;

///////////////////////////////////////
//FSM Definition
///////////////////////////////////////
reg [4:0] state;

//State Machine  
localparam IDLE             = 5'd0, 
  READ_CMD                  = 5'd1, 
  READ_DEVICE_ID_CMD        = 5'd2, 
  READ_JEDEC_ID_CMD         = 5'd4, 
  READ_UNIQUE_ID_CMD        = 5'd5, 
  RESET_CMD                 = 5'd6, 
  WRITE_CMD                 = 5'd7, 
  ERASE_CMD                 = 5'd8, 
  WRITE_DATA                = 5'd9, 
  READ_DATA                 = 5'd10, 
  WRITE_ENABLE_CMD          = 5'd11, 
  WRITE_REG_CMD             = 5'd12, 
  READ_REG_CMD              = 5'd13,
  READ_MANUFACTURING_ID_CMD = 5'd14,
  WRITE_ENABLE_VOL_CMD      = 5'd15,
  WRITE_DISABLE_CMD         = 5'd16,
  WBURST_CHK_STATUS         = 5'd17,
  WBURST_WEL_CLR            = 5'd18,
  WBURST_WE_INSTR           = 5'd19,
  WBURST_PAGE               = 5'd20,
  FAST_READ_CMD             = 5'd21,
  READ_DUMMY_DATA           = 5'd22,
  WRITE4B_CMD               = 5'd23,
  READ4B_CMD                = 5'd24,
  ERASE4B_CMD               = 5'd25,
  ENTER_4BYTE		    =5'd26,
  EXIT_4BYTE 		    =5'd27,
  FAST_READ4B_CMD	    = 5'd28;
   
   
   

//Command Setting    
localparam RESETDATA1 = 8'h66, //Enable Reset
  RESETDATA2          = 8'h99, //Reset Device 
  UNIQUEID_DATA       = 8'h4B, //Read Unique ID
  DEVICEID_DATA       = 8'hAB, //Release Power Down / Device ID. 
  WRITEDATA           = 8'h02, //Page Program 
  //WRITE4BDATA         = 8'h12, //Page Program with 4byte address
  WRREG1_DATA         = 8'h01, //Write Status Register-1
  WRREG2_DATA         = 8'h31, //Write Status Register-2
  WRREG3_DATA         = 8'h11, //Write Status Register-3
  RDREG1_DATA         = 8'h05, //Read Status Register-1
  RDREG2_DATA         = 8'h35, //Read Status Register-2
  RDREG3_DATA         = 8'h15, //Read Status Register-3
  JEDECID_DATA        = 8'h9F, //Read JEDEC ID
  MANUFACTURING_ID_DATA = 8'h90, // Read manufacturing id. 
  WRITE_ENABLE_DATA     = 8'h06,              //Write Enable Instruction 
  WRITE_ENABLE_VOLATILE_STAT_DATA = 8'h50,    //Write Enable for Volatile Status Register 
  WRITE_DISABLE_DATA = 8'h04,                 //Write Disable.  
  BREAD_DATA = 8'h03,   // Read
  //BREAD4B_DATA = 8'h13, // Read with 4byte address
  FAST_BREAD_DATA = 8'h0B,
  //FAST_BREAD4B_DATA = 8'h0C,
  CHIP_ERASE_0 = 8'hc7, //CHIP ERASE Command type 0
  CHIP_ERASE_1 = 8'h60, //Chip Erase Command type 1
  SECTOR_ERASE = 8'h20,       //
  BLOCK_32KB_ERASE = 8'h52,   //
  BLOCK_64KB_ERASE = 8'hD8,   //
  //SECTOR_ERASE4B      = 8'h21,
  //BLOCK_64KB_ERASE4B  = 8'hDC,
  WRITE_NONVOLATILE_CONFIGURATION = 8'hb1,
  READ_NONVOLATILE_CONFIGURATION = 8'hb5,
  ENTER_4BYTE_MODE = 8'hB7,
  EXIT_4BYTE_MODE =  8'hE9;
   
   function integer depth2width;
      input [31:0] 	  depth;
      begin
	 if (depth > 1) begin
	    depth = depth - 1;
	    for (depth2width=0; depth>0; depth2width = depth2width + 1)
	      depth = depth>>1;
	 end
	 else
	   depth2width = 0;
      end
   endfunction

   localparam RBIT_CNT_SIZE = depth2width(RFIFO_DEPTH_256*256*8);
   localparam WBIT_CNT_SIZE = depth2width(WFIFO_DEPTH_256*256*8);
   
//Internal Signals    
   reg [7:0] cmd_in;
   reg [7:0] cmd_in_reg;
   
   reg [5:0] cnt,cnt_0;
   reg [5:0] sclkcnt;
   reg [RBIT_CNT_SIZE-1:0] readcnt;
   reg [WBIT_CNT_SIZE-1:0] writecnt;
   wire [RBIT_CNT_SIZE-1:0] r_burst_cnt_max;
   wire [WBIT_CNT_SIZE-1:0] w_burst_cnt_max;
   reg 	      sclk_reg, sclk_reg_d;
   reg 	      read_done;
   reg 	      mosi_reg, nss_reg, busy_reg, data_valid_reg;
   reg [7:0]  data_in_reg, data_out_reg, data_out_reg_d;
   reg [31:0] address_reg;
   reg [31:0] flash_address_reg;
   
   reg 	      spi_cmd_en0,spi_cmd_en1;
   wire       spi_cmd_en_pos;
   reg 	      burst_wr_flag;
   reg 	      burst_rd_flag;
   
   reg 	      wfifo_rd0,wfifo_rd1;
   reg 	      data_valid_reg0;
   reg 	      data_valid_reg1;
   reg         fourbyte_cmd;
   reg [5:0]  cnt_max;
   reg [7:0]  spi_cmd_instr_reg;
   wire       sclk_reg_neg;
   wire       sclk_reg_pos;
   
   assign fsm_status =  state;
   assign mosi = mosi_reg;
   assign nss = nss_reg;
   assign busy = busy_reg;
   assign data_valid = (burst_rd_flag) ? data_valid_reg0 & ~data_valid_reg1 : 1'b0;
   assign data_out = data_out_reg_d;

//////////////////////////////
// SCLK Clock Generation
//////////////////////////////
  
   always @(posedge clkin)
     begin
	if (!nrst) begin
	   sclkcnt <= 6'd0;
	   sclk_reg <= 1'b0;
	   sclk_reg_d <= 1'b0;
	end
	else begin
	   if (sclkcnt == SCLK_FREQ) begin
	      sclk_reg <= ~sclk_reg;
	      sclkcnt <= 6'd0;
	   end
	   else begin
	      sclkcnt <= sclkcnt + 1'b1;
	   end
	   sclk_reg_d <= sclk_reg;
	end
     end // always @ (posedge clkin)
   
   assign sclk = sclk_reg;   
   assign sclk_reg_neg = (sclk_reg == 1'b0 && sclk_reg_d == 1'b1);
   assign sclk_reg_pos = (sclk_reg == 1'b1 && sclk_reg_d == 1'b0);
   
     
   //To decode the command instruction counter.
 //   always @(*)
 //     begin
	// case (spi_cmd_instr[7:0])
 //     BREAD4B_DATA : fourbyte_cmd = 1'b1;
	//   CHIP_ERASE_0 : cnt_max[5:0] = 6'd8;
	//   CHIP_ERASE_1 : cnt_max[5:0] = 6'd8;
	//   default      : cnt_max[5:0] = 6'd32; //Sector/Block Erase.
	// endcase // case (spi_cmd_instr[7:0])
 //     end

always @(posedge clkin)
      if (~nrst) begin
         fourbyte_cmd <= 1'b0;
         cnt_max <= 6'h32;
      end
      else begin
         case (spi_cmd_instr[7:0])
           
           CHIP_ERASE_0 		: cnt_max[5:0] <= 6'd8;
           CHIP_ERASE_1 		: cnt_max[5:0] <= 6'd8;
           SECTOR_ERASE 		: begin 
                                    if (fourbyte_cmd)
                                    cnt_max[5:0] <= 6'd40;
                                    else
                                    cnt_max[5:0] <= 6'd32;
                                    end
                                    
           BLOCK_64KB_ERASE	:        begin 
                                    if (fourbyte_cmd)
                                    cnt_max[5:0] <= 6'd40;
                                    else
                                    cnt_max[5:0] <= 6'd32;
                                    end

            
           ENTER_4BYTE_MODE 	:fourbyte_cmd <= 1'b1;
                                   
	   EXIT_4BYTE_MODE 	: fourbyte_cmd <= 1'b0;
                                   
          default            :  begin 
                     				fourbyte_cmd <= 1'b0;
          	  	 			cnt_max[5:0] <= 6'd32; //Sector/Block Erase.
  
                                
                               end
                
         endcase // case (spi_cmd_instr[7:0])
         end


   
   always @(posedge clkin)
     if (~nrst)
       begin
	  spi_cmd_en0 <= 1'b0;
	  spi_cmd_en1 <= 1'b0;
       end
   
     else 
       begin
	  spi_cmd_en0 <= spi_cmd_en;
	  spi_cmd_en1 <= spi_cmd_en0;
       end // else: !if(~nrst)

   assign spi_cmd_en_pos = spi_cmd_en0 & ~spi_cmd_en1;
   
     
   
   
   ////////////////////////////
   //Burst Data Size
   ////////////////////////////

   //For write burst, it's always multiple of 256 bytes. 
   assign w_burst_cnt_max = 'd256;

   //r_burst_size is no. of words multiple of 256
   //Translate to bits r_burst_size*256*8
 // always @(*) begin 
 //    case (r_burst_size)
 //	8'h01  : r_burst_cnt_max = 'd2048 - 1;
 //	8'h02  : r_burst_cnt_max = 'd4096 - 1;
 //	8'h0A  : r_burst_cnt_max = 'd20480 - 1;
 //	8'd20  : r_burst_cnt_max = 'd40960 - 1;
 //	8'd60 : r_burst_cnt_max = 'd122880 - 1;
 //	8'd100 : r_burst_cnt_max = 'd204800 - 1;
 //	default : r_burst_cnt_max = 'd2048 - 1;
 //    endcase // case (r_burst_size)   
 //  end // always @ (*)
   
   assign r_burst_cnt_max = {r_burst_size,11'b0} -1;
   
  //w_burst_size
  //>1 - the state machine will change the burst loop state.
   reg state_loop_flag;
   reg [7:0] spi_wr_burst_size_cnt;
   reg [3:0] instr_wait_cnt;
   
   // SPI state machine
   always @(posedge clkin)
     begin
	if (!nrst) begin
	   nss_reg <= 1'b1;
	   mosi_reg <= 1'b1;
	   busy_reg <= 1'b1;
	   data_valid_reg <= 1'b0;
	   data_out_reg <= 8'd0;
	   data_out_reg_d <= 8'd0;
	   address_reg <= 32'd0;
	   flash_address_reg <= 32'd0;
	   
	   data_in_reg <= 8'd0;
	   state <= IDLE;
	   erase_en <= 1'b0;
	   wfifo_rd0 <= 1'b0;
	   burst_wr_flag <= 1'b0;
	   burst_rd_flag <= 1'b0;
	   page_program_done <= 1'b0;
	   spi_cmd_instr_reg <= 8'h0;
	   writecnt <= {{WBIT_CNT_SIZE}*{1'b0}};
	   readcnt <= {{RBIT_CNT_SIZE}*{1'b0}};
	   cnt <= 6'd0;
	   read_done <= 1'b0;
	   state_loop_flag <= 1'b0;
	   spi_wr_burst_size_cnt <= 8'h1;
	   instr_wait_cnt <= 4'h0;

	   cmd_in <= 'd0;
	   cmd_in_reg <= 'd0;
	   
	   
	end
	else begin
	   case (state)
	     IDLE: begin
		// SPI signals
		nss_reg <= 1'b1;
		mosi_reg <= 1'b1;
		instr_wait_cnt <= 4'h0;
		busy_reg <= 1'b0;
		readcnt <= 'b0;
		read_done <= 1'b0;
		cnt <= 6'd0;		
		
		address_reg <= address;
		flash_address_reg <= address;
		data_valid_reg <= 1'b0;

			
		// state change
		if (spi_cmd_en_pos)
		  begin 
		if (spi_cmd == 5'd21) ////write non volatile register (MT256)////
		  data_in_reg <= wr_nonvolatile_config[7:0]; //start from less significant byte.
		else if (spi_cmd == 5'd23) ////// write 16-bit status reg ////
		  data_in_reg <= status_reg_16B[7:0]; //start from less significant byte.
		else 
		  data_in_reg <= data_in;

		     case (spi_cmd)
		       5'd1: begin	// soft reset 0x1
			  busy_reg <= 1'b1;
			  cmd_in <= RESETDATA1;
			  cmd_in_reg <= RESETDATA1;
			  state <= RESET_CMD;
		       end
		       5'd2: begin	// read data 0x2
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  state <= fourbyte_cmd ? READ4B_CMD : READ_CMD;
			  cmd_in <= BREAD_DATA; //Burst Read Data
			  cmd_in_reg <= BREAD_DATA; //Burst Read Data
			  burst_rd_flag <= 1'b1;
		       end
		       5'd3: begin	// read device id 0x3
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= DEVICEID_DATA;
			  cmd_in_reg <= DEVICEID_DATA;
			  state <= READ_DEVICE_ID_CMD;
			  ////burst_rd_flag <= 1'b1;
		       end
		       5'd4: begin	// read unique id 0x4
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= UNIQUEID_DATA;
			  cmd_in_reg <= UNIQUEID_DATA;
			  state <= READ_UNIQUE_ID_CMD;
		       end
		       5'd5: begin	// read status register 0x5 - data_in as command
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= data_in[7:0];
			  cmd_in_reg <= data_in[7:0];
			  state <= READ_REG_CMD;
		       end
		       5'd6: begin	// read JEDEC id 0x6
			  busy_reg <= 1'b1;
			  cmd_in <= JEDECID_DATA;
			  cmd_in_reg <= JEDECID_DATA;
			  state <= READ_JEDEC_ID_CMD;
		       end
		       5'd8: begin	// write enable 0x8
			  busy_reg <= 1'b1;
			  cmd_in <= WRITE_ENABLE_DATA;
			  cmd_in_reg <= WRITE_ENABLE_DATA;
			  state <= WRITE_ENABLE_CMD;
			  erase_en <= 1'b1;
		       end
		       5'd9: begin	// write status reg 1
			  busy_reg <= 1'b1;
			  cmd_in <= WRREG1_DATA;
			  cmd_in_reg <= WRREG1_DATA;
			  state <= WRITE_REG_CMD;
		       end
		       5'd10: begin	// write status reg 2
			  busy_reg <= 1'b1;
			  cmd_in <= WRREG2_DATA;
			  cmd_in_reg <= WRREG2_DATA;
			  state <= WRITE_REG_CMD;
		       end
		       5'd11: begin	// write status reg 3
			  busy_reg <= 1'b1;
			  cmd_in <= WRREG3_DATA;
			  cmd_in_reg <= WRREG3_DATA;
			  state <= WRITE_REG_CMD;
		       end
		       5'd23: begin	// write 16-bit status reg 
			  busy_reg <= 1'b1;
			  cmd_in <= WRREG1_DATA;
			  cmd_in_reg <= WRREG1_DATA;
			  state <= WRITE_REG_CMD;
		       end
		       5'd12: begin	// page program 0xC
			  busy_reg <= 1'b1;
			  cmd_in <=  WRITEDATA;
			  cmd_in_reg <=  WRITEDATA;
			  state <= fourbyte_cmd ? WRITE4B_CMD: WRITE_CMD;
			  wfifo_rd0 <= 1'b1;
			  burst_wr_flag <= 1'b1;
			  spi_wr_burst_size_cnt <= w_burst_size;
		       end
		       5'd13: begin	// erase page 0xD
			  busy_reg <= 1'b1;
			  state <= fourbyte_cmd ? ERASE4B_CMD : ERASE_CMD;
			  spi_cmd_instr_reg <= spi_cmd_instr;
			  
		       end
		       5'd14: begin	// read status register 0x05 - data_in as command
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= RDREG1_DATA;
			  cmd_in_reg <= RDREG1_DATA;
			  state <= READ_REG_CMD;
		       end
		       5'd15: begin	// read status register 0x35 - data_in as command
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= RDREG2_DATA;
			  cmd_in_reg <= RDREG2_DATA;
			  
			  state <= READ_REG_CMD;
		       end
		       5'd16: begin	// read status register 0x15 - data_in as command
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= RDREG3_DATA;
			  cmd_in_reg <= RDREG3_DATA;
			  state <= READ_REG_CMD;
		       end

		       5'd17: begin	// read manufacturing id
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= MANUFACTURING_ID_DATA;
			  cmd_in_reg <= MANUFACTURING_ID_DATA;
			  state <= READ_MANUFACTURING_ID_CMD;
		       end

		       5'd18: begin	// write volatile status enable 0x18
			  busy_reg <= 1'b1;
			  cmd_in <= WRITE_ENABLE_VOLATILE_STAT_DATA;
 			  address_reg <= address;
			  flash_address_reg <= address;
			  cmd_in_reg <= WRITE_ENABLE_VOLATILE_STAT_DATA;
			  state <= WRITE_ENABLE_VOL_CMD;
		       end
		       
		       5'd19: begin	// write disable 0x19
			  busy_reg <= 1'b1;
			  cmd_in <= WRITE_DISABLE_DATA;
			  cmd_in_reg <= WRITE_DISABLE_DATA;
			  state <= WRITE_DISABLE_CMD;
			  erase_en <= 1'b0;
		       end
		             
		       
		       5'd20: begin // fast read
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  state <= fourbyte_cmd ? FAST_READ4B_CMD : FAST_READ_CMD;
			  cmd_in <= FAST_BREAD_DATA;  //Burst Read Data
			  cmd_in_reg <=  FAST_BREAD_DATA;  //Burst Read Data
			  burst_rd_flag <= 1'b0;
		       end

		       5'd21: begin	 // write non volatile register (MT256)
			  busy_reg <= 1'b1;
			  cmd_in <= WRITE_NONVOLATILE_CONFIGURATION;
			  cmd_in_reg <= WRITE_NONVOLATILE_CONFIGURATION;
			  state <= WRITE_REG_CMD;
			  
		       end

		       5'd22: begin	 // read non volatile register (MT256)
			  data_out_reg_d <= 8'd0;
			  busy_reg <= 1'b1;
			  cmd_in <= READ_NONVOLATILE_CONFIGURATION;
			  cmd_in_reg <= READ_NONVOLATILE_CONFIGURATION;
			  state <= READ_REG_CMD;
			  
		       end
		      
		       
5'd26: begin // ENTER_4BYTE_ADDRESS_MODE		       
data_out_reg_d <= 8'd0;			  
busy_reg <= 1'b1;			  
state <= ENTER_4BYTE;			  
cmd_in <=ENTER_4BYTE_MODE; //Burst Read Data		
cmd_in_reg <=ENTER_4BYTE_MODE; //Burst Read Data	
//burst_rd_flag <= 1'b0;			  
 end		      
                           
 5'd27: begin // EXIT 		     
data_out_reg_d <= 8'd0;			  
busy_reg <= 1'b1;			  
state <= EXIT_4BYTE;			  
cmd_in <=EXIT_4BYTE_MODE; //Burst Read Data	
cmd_in_reg <=EXIT_4BYTE_MODE; //Burst Read Data	
//burst_rd_flag <= 1'b0;			 
 end	
		       
     
		     endcase // case (spi_cmd)

		     page_program_done <= 1'b0;
		  end // if (spi_cmd_en)
		
		else begin
		   busy_reg <= 1'b0;
		   cmd_in <= 8'h00;
		   wfifo_rd0 <= 1'b0;
		   state <= IDLE;		   
		end // else: !if(spi_cmd_en)
	       
	     end // case: IDLE

     	ENTER_4BYTE: begin	// enter 4byte address mode
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   nss_reg <= 1'b0;
		   if (cnt < 6'd8) begin
		    nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		       //busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd8) begin
		    data_valid_reg <= 1'd1;
		      cnt <= 6'd0;
		      nss_reg <= 1'b1;
			state <= IDLE;
		      
		
		   end
		end
	     end


  	EXIT_4BYTE: begin	// exit 4byte address mode
		if (sclk_reg_neg)begin  // negedge of sclkreg
		   nss_reg <= 1'b0;
		   if (cnt < 6'd8) begin
		    nss_reg <= 1'b0;
		    mosi_reg <= cmd_in[7];
		    cmd_in <= {cmd_in[6:0], 1'b0};
		      // busy_reg <= 1'b1;
		    cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd8) begin
		   data_valid_reg <= 1'd1;
		   cnt <= 6'd0;
		   nss_reg <= 1'b1;
		   state <= IDLE;
		      
		   end
		end
	     end
	     

	     //Burst Read Data with 1 page (256 bytes). 
	     READ_CMD: begin			// data_in with read buffer command 0x03
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];	
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < 6'd32) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= address_reg[23];
		      address_reg <= {address_reg[22:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd32) begin
		      readcnt <= r_burst_cnt_max;	// read 256 bytes (2048 bits) data
		      cnt <= 6'd0;
		      state <= READ_DATA;
		   end
		end
	     end // case: READ_CMD

        //Burst Read Data with 1 page (256 bytes). 
        READ4B_CMD: begin       // data_in with read buffer command 0x13
      if (sclk_reg_neg) begin  // negedge of sclkreg
         if (cnt < 6'd8) begin
            nss_reg <= 1'b0;
            mosi_reg <= cmd_in[7];  
            cmd_in <= {cmd_in[6:0], 1'b0};
            busy_reg <= 1'b1;
            cnt <= cnt + 1'b1;
         end
         else if (cnt < 6'd40) begin
            nss_reg <= 1'b0;
            mosi_reg <= address_reg[31];
            address_reg <= {address_reg[30:0], 1'b0};
            cnt <= cnt + 1'b1;
         end
         else if (cnt == 6'd40) begin
            readcnt <= r_burst_cnt_max;   // read 256 bytes (2048 bits) data
            cnt <= 6'd0;
            state <= READ_DATA;
         end
      end
        end // case: READ4B_CMD


	     //Burst Read Data with 1 page (256 bytes). 
	     FAST_READ_CMD: begin			// data_in with read buffer command 0x03
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];	
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < 6'd32) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= address_reg[23];
		      address_reg <= {address_reg[22:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd32) begin
		      readcnt <= 'd7;	// read 256 bytes (2048 bits) data
		      cnt <= 6'd0;
		      state <= READ_DUMMY_DATA;
		   end
		end
	     end
	     
/*   
	     //Burst Read Data with 1 page (256 bytes). 
        FAST_READ4B_CMD: begin       // data_in with read buffer command 0x13
      if (sclk_reg_neg) begin  // negedge of sclkreg
         if (cnt < 6'd8) begin
            nss_reg <= 1'b0;
            mosi_reg <= cmd_in[7];  
            cmd_in <= {cmd_in[6:0], 1'b0};
            busy_reg <= 1'b1;
            cnt <= cnt + 1'b1;
         end
         else if (cnt < 6'd40) begin  ////(cnt < (6'd8 + ADDR_WIDTH)) 
            nss_reg <= 1'b0;
            mosi_reg <= address_reg[31]; ////address_reg[ADDR_WIDTH-1];
            address_reg <= {address_reg[30:0], 1'b0}; ////{address_reg[ADDR_WIDTH-2:0], 1'b0};
            cnt <= cnt + 1'b1;
         end
         else if (cnt == 6'd40) begin
            readcnt <= 'd7;  // read 256 bytes (2048 bits) data
            cnt <= 6'd0;
            state <= READ_DUMMY_DATA;
         end
      end
        end // case: FAST_READ4B_CMD 
	     
	*/     
	     
	     READ_DEVICE_ID_CMD: begin	// send command 0xAB
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   nss_reg <= 1'b0;
		   if (cnt < 6'd8) begin
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < 6'd32) begin
		      mosi_reg <= 1'b0;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd32) begin
		      cnt <= 6'd0;
		      readcnt <= 'd7;	// read 8 bits
		      state <= READ_DATA;
		   end
		end
	     end // case: READ_DEVICE_ID_CMD


	     READ_MANUFACTURING_ID_CMD: begin	// send command 0x90
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   nss_reg <= 1'b0;
		   if (cnt < 6'd8) begin
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < 6'd32) begin
		      mosi_reg <= 1'b0;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd32) begin
		      cnt <= 6'd0;
		      readcnt <= 'd7;	// read 8 bits
		      state <= READ_DATA;
		   end
		end
	     end
	     
	     READ_UNIQUE_ID_CMD: begin	// send command 0x4B
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   nss_reg <= 1'b0;
		   if (cnt < 6'd8) begin
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < 6'd40) begin
		      mosi_reg <= 1'b0;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd40) begin
		      cnt <= 6'd0;
		      readcnt <= 'd63;	// read 64 bits
		      state <= READ_DATA;
		   end
		end
	     end
	     
	     READ_JEDEC_ID_CMD: begin	// send command 0x9F
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   nss_reg <= 1'b0;
		   if (cnt < 6'd8) begin
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd8) begin
		      cnt <= 6'd0;
		      readcnt <= 'd23;	// read 24 bits (3 bytes)
		      state <= READ_DATA;
		   end
		end
	     end
	     
	     READ_REG_CMD: begin	// send read status register command 0x05, 0x35, 0x15 (data_in)
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   nss_reg <= 1'b0;
		   if (cnt < 6'd8) begin
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd8) begin
		      cnt <= 6'd0;
		      state <= READ_DATA;
		     
		      if (cmd_in_reg == READ_NONVOLATILE_CONFIGURATION)
			readcnt <= 'd15;	// read 16 bits
		      else
			readcnt <= 'd7;         // read 8 bits
		      

		   end
		end
	     end
	     
	     RESET_CMD: begin
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];	
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < 6'd11) begin
		      nss_reg <= 1'b1;
		      mosi_reg <= 1'b0;
		      cmd_in <= RESETDATA2;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < 6'd19) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd19) begin
		      nss_reg <= 1'b1;
		      mosi_reg <= 1'b1;
		      cnt <= 6'd0;
		      busy_reg <= 1'b0;
		      data_valid_reg <= 1'd1;
		      state <= IDLE;
		   end
		end
	     end
	     
	     WRITE_ENABLE_CMD: begin	                           // enable page program, erase command
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd8) begin
		      data_valid_reg <= 1'd1;
		      cnt <= 6'd0;
		      if (state_loop_flag)
			state <= WBURST_PAGE;
		      else 
			state <= IDLE;
		      
		   end
		   
		end
	     end // case: WRITE_ENABLE_CMD

	     WRITE_ENABLE_VOL_CMD: begin	// enable page program, erase command
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd8) begin
		      data_valid_reg <= 1'd1;
		      cnt <= 6'd0;
		      state <= IDLE;
		   end
		   
		end
	     end // case: WRITE_ENABLE_CMD


	     WRITE_DISABLE_CMD: begin	// enable page program, erase command
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd8) begin
		      data_valid_reg <= 1'd1;
		      cnt <= 6'd0;
		      state <= IDLE;
		   end
		   
		end
	     end // case: WRITE_ENABLE_CMD
	     
	     
	     
	     WRITE_REG_CMD: begin	// write status register command
		if (sclk_reg_neg) begin  // negedge of sclkreg	
		   nss_reg <= 1'b0;
		   busy_reg <= 1'b1;
		   if (cnt < 6'd8) begin
		      cnt <= cnt + 1'b1;
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		   end
		   else if (cnt == 6'd8) begin
		      if (cmd_in_reg == WRITE_NONVOLATILE_CONFIGURATION) begin  //5'd23 = INTREG0_SPI_WR_16B_STATUS
			     writecnt <= 'd2;	// write 1 byte
			     cnt <= 6'd0;
			     mosi_reg <= data_in_reg[7];
			     data_in_reg <= {data_in_reg[6:0], 1'b0};
			     state <= WRITE_DATA;
		      end
		      else if (spi_cmd == 5'd23) begin  //5'd23 = INTREG0_SPI_WR_16B_STATUS
			     writecnt <= 'd2;	// write 1 byte
			     cnt <= 6'd0;
			     mosi_reg <= data_in_reg[7];
			     data_in_reg <= {data_in_reg[6:0], 1'b0};
			     state <= WRITE_DATA;
		      end
		      else begin
			     writecnt <= 'd1;	// write 1 byte
			     cnt <= 6'd0;
			     mosi_reg <= data_in_reg[7];
			     data_in_reg <= {data_in_reg[6:0], 1'b0};
			     state <= WRITE_DATA;
		      end // else: !if(cmd_in == WRITE_NONVOLATILE_CONFIGURATION)
		   end
		end
	     end
	     
	     WRITE_CMD: begin	// page program
		wfifo_rd0 <= 1'b0;

		
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   //cmd phase
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= cmd_in[7];
		      cmd_in <= {cmd_in[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   
		   //address phase
		   else if (cnt < 6'd32) begin
		      nss_reg <= 1'b0;
		      cnt <= cnt + 1'b1;
		      
		     // if (state_loop_flag)
		     //	begin
		     //	   mosi_reg <= flash_address_reg[23];
		     //	   address_reg <= {flash_address_reg[22:0], 1'b0};
		     //	end
		     //else begin
			 mosi_reg <= address_reg[23];
			 address_reg <= {address_reg[22:0], 1'b0};
		     // end
		      
		      
		   end
		   //data phase. 
		   else if (cnt == 6'd32) begin
		      //writecnt <= 12'd0;	// write 256 bytes //write 3 bytes
		      writecnt <= w_burst_cnt_max;	// write 256 bytes //write 3 bytes
		      //mosi_reg <= data_in_reg[7];
		      //data_in_reg <= {data_in_reg[6:0], 1'b0};
		      mosi_reg <= burst_data_wr[7];
		      data_in_reg <= {burst_data_wr[6:0], 1'b0};
		      cnt <= 6'd0;
		      state <= WRITE_DATA;
		   end
		end
	     end

        WRITE4B_CMD: begin   // page program with 4 byte address ( 0x12 )
        wfifo_rd0 <= 1'b0;

      
        if (sclk_reg_neg) begin  // negedge of sclkreg
         //cmd phase
         if (cnt < 6'd8) begin
            nss_reg <= 1'b0;
            mosi_reg <= cmd_in[7];
            cmd_in <= {cmd_in[6:0], 1'b0};
            busy_reg <= 1'b1;
            cnt <= cnt + 1'b1;
         end
         
         //address phase
         else if (cnt < 6'd40) begin
            nss_reg <= 1'b0;
            cnt <= cnt + 1'b1;
            mosi_reg <= address_reg[31];
            address_reg <= {address_reg[30:0], 1'b0};
         end
         //data phase. 
         else if (cnt == 6'd40) begin
            //writecnt <= 12'd0; // write 256 bytes //write 3 bytes
            writecnt <= w_burst_cnt_max;  // write 256 bytes //write 3 bytes
            //mosi_reg <= data_in_reg[7];
            //data_in_reg <= {data_in_reg[6:0], 1'b0};
            mosi_reg <= burst_data_wr[7];
            data_in_reg <= {burst_data_wr[6:0], 1'b0};
            cnt <= 6'd0;
            state <= WRITE_DATA;
         end
        end
        end
	     
	     ERASE_CMD: begin	// data_in with instruction for sector erase 0x20 or block erase 0x52/0xD8
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (cnt < 6'd8) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= spi_cmd_instr_reg[7];
		      spi_cmd_instr_reg <= {spi_cmd_instr_reg[6:0], 1'b0};
		      busy_reg <= 1'b1;
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt < cnt_max) begin
		      nss_reg <= 1'b0;
		      mosi_reg <= address_reg[23];
		      address_reg <= {address_reg[22:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == cnt_max) begin
		      nss_reg <= 1'b1;
		      mosi_reg <= 1'b1;
		      cnt <= 6'd0;
		      busy_reg <= 1'b0;
		      data_valid_reg <= 1'd1;
		      state <= IDLE;
		   end
		end
	     end

        ERASE4B_CMD: begin   // Erase with 4byte address ( sector erase 0x21 or block erase 0xDC )
      if (sclk_reg_neg) begin  // negedge of sclkreg
         if (cnt < 6'd8) begin
            nss_reg <= 1'b0;
            mosi_reg <= spi_cmd_instr_reg[7];
            spi_cmd_instr_reg <= {spi_cmd_instr_reg[6:0], 1'b0};
            busy_reg <= 1'b1;
            cnt <= cnt + 1'b1;
         end
         else if (cnt < cnt_max) begin
            nss_reg <= 1'b0;
            mosi_reg <= address_reg[31];
            address_reg <= {address_reg[30:0], 1'b0};
            cnt <= cnt + 1'b1;
         end
         else if (cnt == cnt_max) begin
            nss_reg <= 1'b1;
            mosi_reg <= 1'b1;
            cnt <= 6'd0;
            busy_reg <= 1'b0;
            data_valid_reg <= 1'd1;
            state <= IDLE;
         end
      end
        end
	     
	     WRITE_DATA: begin	// data valid goes 1 when 1 byte has been written on SPI data bus
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   mosi_reg <= data_in_reg[7];
		   if (cnt < 6'd6) begin
		      nss_reg <= 1'b0;
		      data_valid_reg <= 1'b0;
		      data_in_reg <= {data_in_reg[6:0], 1'b0};
		      cnt <= cnt + 1'b1;
		   end
		   else if (cnt == 6'd6) begin
		      cnt <= cnt + 1'b1;
		      if (cmd_in_reg == WRITE_NONVOLATILE_CONFIGURATION) begin
                  data_in_reg <= wr_nonvolatile_config[15:8];
              end
		      else if (spi_cmd == 5'd23) begin
                  data_in_reg <= status_reg_16B[15:8];
              end
		      else begin
                  data_in_reg <= (burst_wr_flag)? burst_data_wr : data_in;
              end
		   end
		   else if (cnt == 6'd7) begin
		      writecnt <= writecnt - 1'b1;
		      data_in_reg <= {data_in_reg[6:0], 1'b0};
		      data_valid_reg <= 1'b1;
		      cnt <= 6'd0;
		   end

		   if (burst_wr_flag & cnt == 6'd5 & writecnt != 'd1)
		     wfifo_rd0 <= 1'b1;
		   else
		     wfifo_rd0 <= 1'b0;
		   
		   
	
		   if ((writecnt == 'd1) && (cnt == 6'd7)) begin
		      nss_reg <= 1'b1;
		      busy_reg <= 1'b0;
		      //state <= IDLE;
		      burst_wr_flag <= 1'b0; //clear the burst write flag.
		      if (spi_wr_burst_size_cnt == 8'h1)
			begin 
			   page_program_done <= (burst_wr_flag) ? 1'b1 : 1'b0;
			   state <= IDLE;
			   state_loop_flag <= 1'b0;
			end
		      else
			begin
			   page_program_done <= 1'b0;
			   state <= WBURST_CHK_STATUS;
			end
		         
		   end // if ((writecnt == 'd1) && (cnt == 6'd7))
		   
		end
	     end

	     WBURST_CHK_STATUS : begin
		nss_reg <= 1'b1;
		mosi_reg <= 1'b1;
		readcnt <= 'b0;
		read_done <= 1'b0;
		cnt <= 6'd0;

		
		data_out_reg_d <= 8'd0;
		busy_reg <= 1'b1;
		cmd_in <= RDREG1_DATA;
		state_loop_flag <= 1'b1;
		instr_wait_cnt <= instr_wait_cnt + 1;
		if (instr_wait_cnt == 4'hf)
		  begin
		     state <= READ_REG_CMD;
		     instr_wait_cnt <= 4'h0;
		  end
		
	     end // case: WBURST_CHK_STATUS

	     WBURST_WEL_CLR : begin
		if (data_out_reg_d[1] == 1'b0) //WEL flag is clear.*TO FIX - 
		  state <= WBURST_WE_INSTR;
		else //Repeat again if not clear.
		  state <= WBURST_CHK_STATUS;
	     end

	     WBURST_WE_INSTR : begin
		nss_reg <= 1'b1;
		mosi_reg <= 1'b1;
		readcnt <= 'b0;
		read_done <= 1'b0;
		cnt <= 6'd0;
		
		busy_reg <= 1'b1;
		cmd_in <= WRITE_ENABLE_DATA;
		erase_en <= 1'b1;
		instr_wait_cnt <= instr_wait_cnt + 1;

		if (instr_wait_cnt == 4'hf)
		  begin
		     state <= WRITE_ENABLE_CMD;
		     instr_wait_cnt <= 4'h0;
		  end
	     end // case: WBURST_WE_INSTR

	     WBURST_PAGE : begin
		nss_reg <= 1'b1;
		mosi_reg <= 1'b1;
		readcnt <= 'b0;
		read_done <= 1'b0;
		cnt <= 6'd0;
		
		
		busy_reg <= 1'b1;
     	        cmd_in <= WRITEDATA;
		wfifo_rd0 <= 1'b1;
		burst_wr_flag <= 1'b1;
	
	
		instr_wait_cnt <= instr_wait_cnt + 1;

		if (instr_wait_cnt == 4'hf)
		  begin
		     flash_address_reg <= flash_address_reg + 256;
		     spi_wr_burst_size_cnt <= spi_wr_burst_size_cnt-1; 
           state <= fourbyte_cmd ? WRITE4B_CMD : WRITE_CMD;
		     address_reg <= flash_address_reg + 256;
		     instr_wait_cnt <= 4'h0;
		  end
	     end
	     
	     READ_DUMMY_DATA: begin
		if (sclk_reg_pos) begin  // posedge of sclkreg
		   data_out_reg <= {data_out_reg[6:0], miso};
		   readcnt <= readcnt - 1'b1;
		   if (cnt < 6'd7) begin
		      data_valid_reg <= 1'b0;
		      cnt <= cnt + 1'b1;
		   end
		   else begin
		      data_out_reg_d <= {data_out_reg[6:0], miso};
		      data_valid_reg <= 1'b1;
		      cnt <= 6'd0;
		      if (readcnt == 'd0) begin
			 read_done <= 1'b1;
		      end
		   end
		end
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (read_done == 1'b1) begin
		      burst_rd_flag <= 1'b1;            // set the burst read flag.
		      state <= READ_DATA;
		      read_done <= 1'b0;
		      readcnt <= r_burst_cnt_max;	// read 256 bytes (2048 bits) data
		   end
		end
	     end // case: READ_DUMMY_DATA
	     
	     READ_DATA: begin
		if (sclk_reg_pos) begin  // posedge of sclkreg
		   data_out_reg <= {data_out_reg[6:0], miso};
		   readcnt <= readcnt - 1'b1;
		   if (cnt < 6'd7) begin
		      data_valid_reg <= 1'b0;
		      cnt <= cnt + 1'b1;
		   end
		   else begin
		      data_out_reg_d <= {data_out_reg[6:0], miso};
		      data_valid_reg <= 1'b1;
		      cnt <= 6'd0;
		      if (readcnt == 'd0) begin
			 read_done <= 1'b1;
		      end
		   end
		end
		if (sclk_reg_neg) begin  // negedge of sclkreg
		   if (read_done == 1'b1) begin
		    
		      burst_rd_flag <= 1'b0; //clear the burst read flag.
		      
		      if (state_loop_flag)
			state <= WBURST_WEL_CLR;
		      else 
			state <= IDLE;
		      
		   end
		end
	     end
	     
	     default: begin
		state <= IDLE;
	     end
	   endcase
	end
     end // always @ (posedge clkin)
   
  

   //To update those read register from SPI Flash.
   always @(posedge clkin)
     if (~nrst)
       begin
	  data_valid_reg0 <= 1'b0;
	  data_valid_reg1 <= 1'b0;
	  wfifo_rd1 <= 1'b0;
       end
     else
       begin
	  data_valid_reg0 <= data_valid_reg;
	  data_valid_reg1 <= data_valid_reg0;
	  wfifo_rd1 <= wfifo_rd0;
	  
       end
   assign wfifo_rd = wfifo_rd0 && ~wfifo_rd1;
   
   
   always @(posedge clkin)
     if (!nrst) begin 
	manufacturing_id_reg <= 8'h0;
	jedec_id_reg <= 24'h0;
	unique_id_reg <= 64'h0;
	device_id_reg <= 8'h0;
	spi_flash_rd_status_reg0 <= 8'h0;
	spi_flash_rd_status_reg1 <= 8'h0;
	spi_flash_rd_status_reg2 <= 8'h0;
	spi_flash_rd_nonvolatile_config <= 16'hFFFF;
     end
   
     else if (data_valid_reg0 & ~data_valid_reg1) begin 
       case (spi_cmd)
	 5'd6  : jedec_id_reg[23:0]              <= {data_out_reg_d,jedec_id_reg[23:8]};
	 5'd17 : manufacturing_id_reg[7:0]       <= data_out_reg_d;
	 5'd4  : unique_id_reg[63:0]             <= {unique_id_reg[55:0],data_out_reg_d};
	 5'd3  : device_id_reg                   <= data_out_reg_d;
	 5'd14 : spi_flash_rd_status_reg0        <= data_out_reg_d;
	 5'd15 : spi_flash_rd_status_reg1        <= data_out_reg_d;
	 5'd16 : spi_flash_rd_status_reg2        <= data_out_reg_d;
	 5'd22 : spi_flash_rd_nonvolatile_config <= {data_out_reg_d,spi_flash_rd_nonvolatile_config[15:8]};
	 default : ;
       endcase // case (spi_cmd)
     end
   
   
	 
	  
endmodule // efx_spi_shifter



/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2013-2019 Efinix Inc. All rights reserved.
//
// Single RAM block
//
// *******************************
// Revisions:
// 0.0 Initial rev
// 0.1 Added output register
// 1.0 Finalized RTL macro
// *******************************

module `IP_MODULE_NAME(simple_dual_port_ram)
#(
	parameter DATA_WIDTH	= 8,
	parameter ADDR_WIDTH	= 9,
	parameter OUTPUT_REG	= "TRUE",
	parameter RAM_INIT_FILE	= ""
)
(
	input [(DATA_WIDTH-1):0] wdata,
	input [(ADDR_WIDTH-1):0] waddr, raddr,
	input we, wclk, re, rclk,
	output [(DATA_WIDTH-1):0] rdata
);

	localparam MEMORY_DEPTH = 2**ADDR_WIDTH;
	localparam MAX_DATA = (1<<ADDR_WIDTH)-1;
	
	reg [DATA_WIDTH-1:0] ram[MEMORY_DEPTH-1:0];
	reg [DATA_WIDTH-1:0] r_rdata_1P;
	reg [DATA_WIDTH-1:0] r_rdata_2P;
	
	integer i;
	initial
	begin
	// By default the Efinix memory will initialize to 0
		if (RAM_INIT_FILE != "")
		begin
			$readmemh(RAM_INIT_FILE, ram);
		end
	end
	
	always @ (posedge wclk)
		if (we)
		ram[waddr] <= wdata;
	
	always @ (posedge rclk)
	begin
		if (re)
			r_rdata_1P <= ram[raddr];
		r_rdata_2P <= r_rdata_1P;
	end
	
	generate
		if (OUTPUT_REG == "TRUE")
			assign	rdata = r_rdata_2P;
		else
			assign	rdata = r_rdata_1P;
	endgenerate

endmodule




`resetall
`timescale 1 ps/1 ps

module `IP_MODULE_NAME(asymwidth_dcfifo)   //assymmetric dc fifo
#(
	parameter	WDATA_WIDTH	= 4,
    parameter   WFIFO_DEPTH = 256,
    parameter   RDATA_WIDTH = 8,
    parameter   RFIFO_DEPTH = 128
)(
    i_arst,
    i_wclk,
    i_we,
    i_wdata,
    i_rclk,
    i_re,
    o_full,
    o_empty,
    o_rdata
);

input wire 					    i_arst;
input wire 					    i_wclk;
input wire 					    i_we;
input wire [WDATA_WIDTH-1:0]	i_wdata;
input wire 					    i_rclk;
input wire 					    i_re;
output wire 			        o_full;
output wire 					o_empty;
output wire [RDATA_WIDTH-1:0]	o_rdata;

wire [3:0] o_rdata_0, o_rdata_1;
reg wr_mux;
wire o_empty_0, o_empty_1;

localparam RADDR_WIDTH = $clog2(RFIFO_DEPTH);
localparam WADDR_WIDTH = $clog2(WFIFO_DEPTH);

assign o_empty = o_empty_0 && o_empty_1;
assign o_rdata = {o_rdata_1, o_rdata_0};

always @(posedge i_wclk) begin
    if (i_arst) begin
        wr_mux    <= 1'b0;
    end
    else if (i_we) begin
        if (wr_mux) begin
            wr_mux    <= 1'b0;
        end
        else begin
            wr_mux    <= 1'b1;
        end
    end
end

    `IP_MODULE_NAME(dual_clock_fifo_wrapper)
      #(
        .DATA_WIDTH(WDATA_WIDTH),                 
        .ADDR_WIDTH(RADDR_WIDTH),      //Address - 24 bits.
        .LATENCY(1),                      //Flag latency - 1 
        .FIFO_MODE("STD_FIFO"),           //Standard FIFO
        .RAM_INIT_FILE(""),               //No Intialization file for ram.
        .COMPATIBILITY("E"),              //
        .OUTPUT_REG("FALSE"),             //No output register. 
        .CHECK_FULL("TRUE"),              //Skip the write if fifo full.             
        .CHECK_EMPTY("TRUE"),             //Skip the read if fifo empty. 
        .AFULL_THRESHOLD(RFIFO_DEPTH-1),
        .AEMPTY_THRESHOLD(1)
        )
    u_wfifo_0
      (
       .i_arst    (i_arst),
       .i_wclk    (i_wclk),
       .i_we      (i_we && wr_mux),
       .i_wdata   (i_wdata),
       .i_rclk    (i_rclk),          
       .i_re      (i_re),           //TBD - Connect to SPI Shifter. 
       .o_full    (),              
       .o_empty   (o_empty_0),        //Indicate that the FIFO is empty, ready for software to do burst write. 
       .o_rdata   (o_rdata_0),
       .o_afull   (),
       .o_wcnt    (),
       .o_aempty  (),
       .o_rcnt    ()
       );
      
    `IP_MODULE_NAME(dual_clock_fifo_wrapper)
     #(
       .DATA_WIDTH(WDATA_WIDTH),                     
       .ADDR_WIDTH(RADDR_WIDTH),      //Address - 24 bits.
       .LATENCY(1),                      //Flag latency - 1 
       .FIFO_MODE("STD_FIFO"),           //Standard FIFO
       .RAM_INIT_FILE(""),               //No Intialization file for ram.
       .COMPATIBILITY("E"),              //
       .OUTPUT_REG("FALSE"),             //No output register. 
       .CHECK_FULL("TRUE"),              //Skip the write if fifo full.             
       .CHECK_EMPTY("TRUE"),             //Skip the read if fifo empty. 
       .AFULL_THRESHOLD(RFIFO_DEPTH-1),
       .AEMPTY_THRESHOLD(1)
       )
   u_wfifo_1
     (
      .i_arst    (i_arst),
      .i_wclk    (i_wclk),
      .i_we      (i_we && ~wr_mux),
      .i_wdata   (i_wdata),
      .i_rclk    (i_rclk),          
      .i_re      (i_re),           //TBD - Connect to SPI Shifter. 
      .o_full    (),              
      .o_empty   (o_empty_1),        //Indicate that the FIFO is empty, ready for software to do burst write. 
      .o_rdata   (o_rdata_1),
      .o_afull   (),
      .o_wcnt    (),
      .o_aempty  (),
      .o_rcnt    ()
      );
      
endmodule
`undef IP_UUID
`undef IP_NAME_CONCAT
`undef IP_MODULE_NAME
